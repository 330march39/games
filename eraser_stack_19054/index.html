<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eraser Stack - 消しゴムタワー</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Matter.js (Physics Engine) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Noto+Sans+JP:wght@400;700;900&display=swap');

        html, body {
            height: 100%;
            height: 100dvh; /* スマホのアドレスバー対策 */
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #f8fafc;
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #app-root {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        #canvas-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
            background-color: #ffffff;
            /* 背景画像の設定（スクロールはJSで制御） */
            background-image: 
                linear-gradient(#e2e8f0 1px, transparent 1px),
                linear-gradient(90deg, #e2e8f0 1px, transparent 1px);
            background-size: 40px 40px;
            cursor: crosshair;
            will-change: background-position; /* パフォーマンス最適化 */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls-area {
            height: 120px;
            min-height: 120px;
            background-color: #ffffff;
            border-top: 1px solid #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            box-shadow: 0 -4px 20px rgba(0,0,0,0.05);
            z-index: 20;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 10;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        .animate-float { animation: float 3s ease-in-out infinite; }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .animate-pop { animation: pop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

        /* New Record Animation */
        @keyframes rainbow {
            0% { color: #ef4444; }
            25% { color: #eab308; }
            50% { color: #22c55e; }
            75% { color: #3b82f6; }
            100% { color: #a855f7; }
        }
        .animate-rainbow {
            animation: rainbow 2s linear infinite;
        }

        .btn-push {
            background: #ef4444;
            border-bottom: 6px solid #b91c1c;
            color: white;
            transition: all 0.1s;
        }
        .btn-push:active {
            transform: translateY(4px);
            border-bottom: 2px solid #b91c1c;
        }
        .btn-push.disabled {
            background: #cbd5e1;
            border-bottom: 6px solid #94a3b8;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>

<div id="app-root">
    <div id="canvas-wrapper">
        <div id="game-canvas-container" class="w-full h-full"></div>

        <div class="ui-overlay p-4 flex justify-between items-start">
            <div>
                <div class="text-xs font-bold text-slate-400 uppercase tracking-widest">SCORE</div>
                <div class="flex items-baseline">
                    <span id="score-display" class="text-4xl font-black text-slate-800">0</span>
                    <span class="text-sm font-bold text-slate-500 ml-1">個</span>
                </div>
            </div>
            <div class="text-right">
                <div class="text-xs font-bold text-slate-400 uppercase tracking-widest">BEST</div>
                <div id="best-score-display" class="text-2xl font-bold text-slate-600">0</div>
            </div>
        </div>

        <div id="menu-overlay" class="ui-overlay flex flex-col items-center justify-center bg-white/80 backdrop-blur-sm pointer-events-auto transition-opacity duration-300">
            <div class="text-center">
                <div class="mb-8 animate-float">
                    <h1 class="text-5xl font-black text-slate-800 tracking-tighter mb-2">STACK</h1>
                    <p class="text-slate-500 font-bold text-sm tracking-[0.3em]">ERASER TOWER</p>
                </div>

                <div id="result-panel" class="hidden mb-8 bg-white p-6 rounded-2xl shadow-lg border border-slate-100 relative overflow-hidden">
                    <div id="new-record-badge" class="hidden absolute top-0 right-0 bg-yellow-400 text-white text-[10px] font-bold px-2 py-1 transform translate-x-2 -translate-y-0 rotate-12 shadow-sm">NEW!</div>
                    <div class="text-xs font-bold text-slate-400 mb-1">RECORD</div>
                    <div class="text-4xl font-black text-slate-800" id="final-score">0</div>
                    <div id="new-record-text" class="hidden text-sm font-bold animate-rainbow mt-2 tracking-widest">NEW RECORD!</div>
                </div>

                <button id="start-btn" class="bg-slate-900 text-white px-10 py-4 rounded-full font-bold text-xl shadow-xl hover:bg-slate-800 transition-transform active:scale-95">
                    START GAME
                </button>
            </div>
        </div>
    </div>

    <div id="controls-area">
        <button id="drop-btn" class="btn-push w-full max-w-md h-16 rounded-xl text-2xl font-black tracking-widest flex items-center justify-center gap-2 disabled">
            <span>DROP</span>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path></svg>
        </button>
    </div>
</div>

<script>
    // --- 1. 設定と定数 ---
    const CONFIG = {
        eraser: { w: 120, h: 40 },
        platform: { w: 220, h: 40 },
        swing: { speed: 0.0035, rangeRatio: 0.85 },
        colors: {
            sleeve: '#3b82f6',
            rubber: '#ffffff',
            platform: '#475569'
        }
    };

    // --- 2. Matter.js エイリアス ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Vector = Matter.Vector;

    // --- 3. グローバル変数 ---
    let engine, render, runner;
    let width, height;
    let isGameActive = false;
    let score = 0;
    let bestScore = localStorage.getItem('eraser_stack_best') || 0;
    
    let platformBody;
    let currentPreview = null;
    let stack = [];
    let cameraY = 0;
    
    // 紙吹雪用
    let confettis = [];
    let canvasWrapper; // 背景操作用

    // --- 4. システム初期化 ---
    window.onload = () => {
        const container = document.getElementById('game-canvas-container');
        canvasWrapper = document.getElementById('canvas-wrapper');
        width = container.clientWidth;
        height = container.clientHeight;

        document.getElementById('best-score-display').innerText = bestScore;

        engine = Engine.create();
        engine.positionIterations = 8;
        engine.velocityIterations = 8;

        render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });

        runner = Runner.create();
        Runner.run(runner, engine);
        Render.run(render);

        Events.on(render, 'afterRender', renderGame);
        Events.on(engine, 'beforeUpdate', updateGameLogic);
        Events.on(engine, 'collisionStart', handleCollisions);

        setupUI();
        
        window.addEventListener('resize', () => {
            const newW = container.clientWidth;
            const newH = container.clientHeight;
            render.canvas.width = newW * window.devicePixelRatio;
            render.canvas.height = newH * window.devicePixelRatio;
            width = newW;
            height = newH;
            
            if (isGameActive) {
                updateCamera(true); // 強制更新
            }
        });
    };

    // --- 5. UI入力設定 ---
    function setupUI() {
        const startBtn = document.getElementById('start-btn');
        const dropBtn = document.getElementById('drop-btn');

        startBtn.onclick = () => {
            startGame();
        };

        const handleDrop = (e) => {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (!isGameActive || !currentPreview) return;
            
            dropBtn.classList.add('scale-95');
            setTimeout(() => dropBtn.classList.remove('scale-95'), 100);

            dropEraser();
        };

        dropBtn.addEventListener('mousedown', handleDrop);
        dropBtn.addEventListener('touchstart', handleDrop, { passive: false });
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleDrop(e);
        });
    }

    // --- 6. ゲームサイクル制御 ---

    function startGame() {
        isGameActive = true;
        score = 0;
        stack = [];
        cameraY = 0;
        confettis = [];
        updateScoreDisplay();
        updateBackground(); // 背景リセット

        document.getElementById('menu-overlay').classList.add('opacity-0', 'pointer-events-none');
        document.getElementById('result-panel').classList.add('hidden');
        document.getElementById('drop-btn').classList.remove('disabled');
        
        document.getElementById('new-record-badge').classList.add('hidden');
        document.getElementById('new-record-text').classList.add('hidden');

        Composite.clear(engine.world);
        Engine.clear(engine); 

        const platformY = height - 60; 
        platformBody = Bodies.rectangle(width / 2, platformY, CONFIG.platform.w, CONFIG.platform.h, {
            isStatic: true,
            friction: 1.0,
            label: 'platform',
            render: { visible: false }
        });

        const killZone = Bodies.rectangle(width / 2, height + 200, width * 5, 50, {
            isStatic: true,
            isSensor: true, 
            label: 'killZone'
        });

        Composite.add(engine.world, [platformBody, killZone]);

        updateCamera(true);
        spawnPreview();
    }

    function gameOver() {
        if (!isGameActive) return;
        isGameActive = false;
        playSound('over');

        document.getElementById('drop-btn').classList.add('disabled');

        let isNewRecord = false;
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('eraser_stack_best', bestScore);
            document.getElementById('best-score-display').innerText = bestScore;
            isNewRecord = true;
            spawnConfetti();
            playSound('win');
        }

        const menu = document.getElementById('menu-overlay');
        menu.classList.remove('opacity-0', 'pointer-events-none');
        
        document.getElementById('result-panel').classList.remove('hidden');
        document.getElementById('final-score').innerText = score;
        
        if (isNewRecord) {
            document.getElementById('new-record-badge').classList.remove('hidden');
            document.getElementById('new-record-text').classList.remove('hidden');
        }
        
        document.getElementById('start-btn').innerText = "RETRY";
    }

    // --- 7. ゲームロジック ---

    function spawnPreview() {
        if (!isGameActive) return;

        const previewY = cameraY + (height * 0.25);

        currentPreview = {
            x: width / 2,
            y: previewY, 
            angle: 0,
            color: CONFIG.colors.sleeve
        };
    }

    function dropEraser() {
        if (!currentPreview) return;

        const { x, y, color } = currentPreview;

        const eraser = Bodies.rectangle(x, y, CONFIG.eraser.w, CONFIG.eraser.h, {
            restitution: 0.1,
            friction: 0.8,
            density: 0.002,
            label: 'eraser',
            render: { visible: false },
            plugin: { 
                color: color,
                hasLanded: false 
            } 
        });

        Composite.add(engine.world, eraser);
        stack.push(eraser);
        playSound('drop');

        currentPreview = null;

        setTimeout(() => {
            if (isGameActive) spawnPreview();
        }, 800);
    }

    function updateGameLogic() {
        if (!isGameActive) return;
        
        const time = engine.timing.timestamp;

        // プレビュー揺れ
        if (currentPreview) {
            const offsetX = Math.sin(time * CONFIG.swing.speed) * (width * CONFIG.swing.rangeRatio / 2);
            currentPreview.x = (width / 2) + offsetX;
            currentPreview.y = cameraY + (height * 0.25);
        }

        // カメラロジック
        if (stack.length > 0) {
            let highestY = platformBody.position.y;
            
            stack.forEach(body => {
                if (body.plugin.hasLanded && body.speed < 1.0 && body.position.y < highestY) {
                    highestY = body.position.y;
                }
            });

            const targetCameraY = highestY - (height * 0.55);
            
            if (targetCameraY < cameraY) {
                // Lerpでスムーズに
                cameraY += (targetCameraY - cameraY) * 0.05;
                
                // 整数に丸めて微細な振動を防ぐ
                if (Math.abs(targetCameraY - cameraY) < 0.5) {
                    // ほぼ到達したら微調整をやめる
                    // cameraY = targetCameraY; 
                    // ただしピタッと止めすぎるとガクッとなるので、描画側で整数化する
                }
                
                updateCamera();
            }
        }
    }
    
    function updateCamera(force = false) {
        // カメラ座標を整数に丸める（ジッター防止の鍵）
        const renderY = Math.floor(cameraY);
        
        Render.lookAt(render, {
            min: { x: 0, y: renderY },
            max: { x: width, y: renderY + height }
        });

        // 背景も連動してスクロール
        updateBackground();
    }

    function updateBackground() {
        if (canvasWrapper) {
            // カメラYの逆方向に背景を動かす
            canvasWrapper.style.backgroundPositionY = `${-Math.floor(cameraY)}px`;
        }
    }

    function handleCollisions(event) {
        const pairs = event.pairs;

        pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;

            if (bodyA.label === 'killZone' || bodyB.label === 'killZone') {
                if (bodyA.label === 'eraser' || bodyB.label === 'eraser') {
                    gameOver();
                }
            }

            const isEraserContact = (bodyA.label === 'eraser' && bodyB.label === 'eraser') ||
                                    (bodyA.label === 'eraser' && bodyB.label === 'platform') ||
                                    (bodyB.label === 'eraser' && bodyA.label === 'platform');

            if (isEraserContact) {
                if (bodyA.label === 'eraser') bodyA.plugin.hasLanded = true;
                if (bodyB.label === 'eraser') bodyB.plugin.hasLanded = true;

                const speed = Vector.magnitude(Vector.sub(bodyA.velocity, bodyB.velocity));
                if (speed > 1) playSound('hit');

                const currentStackCount = stack.length;
                if (currentStackCount > score) {
                    score = currentStackCount;
                    updateScoreDisplay();
                }
            }
        });
    }

    function updateScoreDisplay() {
        const el = document.getElementById('score-display');
        el.innerText = score;
        el.classList.remove('animate-pop');
        void el.offsetWidth;
        el.classList.add('animate-pop');
    }

    // --- 8. 描画 ---
    function renderGame() {
        const ctx = render.context;
        const bounds = render.bounds;

        ctx.save();
        // Render.lookAtで設定されたboundsに基づいて描画全体をずらす
        ctx.translate(-bounds.min.x, -bounds.min.y);
        
        // --- 描画開始 ---

        if (platformBody) {
            const { x, y } = platformBody.position;
            drawFancyRect(ctx, x, y, CONFIG.platform.w, CONFIG.platform.h, 0, CONFIG.colors.platform, true);
        }

        stack.forEach(body => {
            const { x, y } = body.position;
            const angle = body.angle;
            const color = body.plugin.color || CONFIG.colors.sleeve;
            drawEraser(ctx, x, y, CONFIG.eraser.w, CONFIG.eraser.h, angle, color, 1.0);
        });

        if (currentPreview) {
            const { x, y, color } = currentPreview;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, cameraY - 200);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#94a3b8";
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            drawEraser(ctx, x, y, CONFIG.eraser.w, CONFIG.eraser.h, 0, color, 0.5);
        }

        // 紙吹雪の描画（座標変換の影響を受けるので、カメラ相対位置からワールド座標に変換して描画）
        updateAndDrawConfetti(ctx);

        // --- 描画終了 ---
        ctx.restore();
    }

    function drawEraser(ctx, x, y, w, h, angle, color, opacity) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.globalAlpha = opacity;

        ctx.shadowColor = "rgba(0,0,0,0.1)";
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 5;

        ctx.fillStyle = CONFIG.colors.rubber;
        roundRect(ctx, -w/2, -h/2, w, h, 4);
        ctx.fill();
        
        ctx.shadowColor = "transparent";

        const sleeveW = w * 0.6;
        ctx.fillStyle = color;
        
        ctx.save();
        roundRect(ctx, -w/2, -h/2, w, h, 4);
        ctx.clip();
        ctx.fillRect(-w/2, -h/2, sleeveW, h);
        ctx.restore();

        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fillRect(-w/2 + 15, -h/2, 5, h);

        ctx.fillStyle = "white";
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ERASER", -w/2 + sleeveW/2, 0);

        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.lineWidth = 1;
        roundRect(ctx, -w/2, -h/2, w, h, 4);
        ctx.stroke();

        ctx.restore();
    }

    function drawFancyRect(ctx, x, y, w, h, angle, color, isPlatform) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        ctx.fillStyle = color;
        
        if (isPlatform) {
            ctx.shadowColor = "rgba(0,0,0,0.2)";
            ctx.shadowBlur = 15;
            ctx.shadowOffsetY = 5;
        }

        roundRect(ctx, -w/2, -h/2, w, h, 6);
        ctx.fill();
        
        if (isPlatform) {
            ctx.shadowColor = "transparent";
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-w/2 + 10, -h/2 + 5);
            ctx.lineTo(w/2 - 10, -h/2 + 5);
            ctx.stroke();
        }

        ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }

    // --- 9. 紙吹雪 (Confetti) ---
    function spawnConfetti() {
        // 画面上部（リザルト画面の上あたり）から発生
        const centerX = width / 2;
        const startY = cameraY + height * 0.2; // 画面上部20%付近
        
        for (let i = 0; i < 100; i++) {
            confettis.push({
                x: centerX,
                y: startY,
                vx: (Math.random() - 0.5) * 25,
                vy: (Math.random() - 0.5) * 25 - 5, // 上方向への初速成分
                angle: Math.random() * 360,
                vAngle: (Math.random() - 0.5) * 10,
                color: `hsl(${Math.random() * 360}, 100%, 60%)`,
                life: 200
            });
        }
    }

    function updateAndDrawConfetti(ctx) {
        if (confettis.length === 0) return;

        for (let i = confettis.length - 1; i >= 0; i--) {
            const p = confettis[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.4; // 重力
            p.vx *= 0.95; // 空気抵抗
            p.angle += p.vAngle;
            p.life--;

            if (p.life <= 0) {
                confettis.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle * Math.PI / 180);
            ctx.fillStyle = p.color;
            ctx.fillRect(-5, -5, 10, 10);
            ctx.restore();
        }
    }

    // --- 10. サウンド ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === 'drop') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            osc.start(now);
            osc.stop(now + 0.05);
        } else if (type === 'over') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.5);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        } else if (type === 'win') {
            // ファンファーレ風
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.setValueAtTime(554, now + 0.1); // C#
            osc.frequency.setValueAtTime(659, now + 0.2); // E
            osc.frequency.setValueAtTime(880, now + 0.3); // A
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.6);
            osc.start(now);
            osc.stop(now + 0.6);
        }
    }
</script>
</body>
</html>
