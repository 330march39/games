<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Make 10: Neon Drop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@700&display=swap');

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #050505;
            color: #ffffff;
            overflow: hidden;
            touch-action: none;
            /* 背景に微かなグラデーションを追加 */
            background: radial-gradient(circle at 50% 10%, #1a1a2e 0%, #000000 100%);
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2997ff, #005ecb);
            box-shadow: 0 0 20px rgba(41, 151, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }
        .btn-primary:after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .btn-primary:active {
            transform: scale(0.94);
            box-shadow: 0 0 10px rgba(41, 151, 255, 0.1);
        }
        .btn-primary:active:after {
            opacity: 1;
        }
        
        /* ネオンテキスト */
        .neon-text {
            text-shadow: 0 0 10px rgba(255,255,255,0.5), 0 0 20px rgba(41, 151, 255, 0.3);
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none z-10 select-none">
        <div class="flex flex-col gap-1">
            <div class="text-[10px] text-gray-400 tracking-[0.2em] font-bold uppercase opacity-70">SCORE</div>
            <div id="scoreDisplay" class="text-3xl font-bold text-white tabular-nums font-['JetBrains_Mono'] tracking-tighter neon-text">0</div>
        </div>
        <div class="flex flex-col gap-2 items-end">
            <div class="text-[10px] text-gray-400 tracking-[0.2em] font-bold uppercase opacity-70">NEXT</div>
            <!-- Next Piece Preview Container -->
            <div class="relative">
                <div class="absolute inset-0 bg-blue-500/20 blur-xl rounded-full"></div>
                <div id="nextPieceDisplay" class="relative w-12 h-12 rounded-xl bg-white/5 border border-white/10 flex items-center justify-center text-2xl font-bold text-white shadow-2xl backdrop-blur-md">
                    <!-- JS Populated -->
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-20 bg-black/60 backdrop-blur-sm transition-all duration-500">
        <div class="glass-panel p-10 rounded-3xl max-w-sm w-full text-center space-y-8 m-4 border-t border-white/10">
            <div class="space-y-2">
                <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-br from-white to-gray-500 tracking-tight drop-shadow-lg">MAKE 10</h1>
                <div class="h-1 w-12 bg-blue-500 mx-auto rounded-full opacity-80"></div>
                <p class="text-gray-400 text-xs tracking-widest uppercase pt-2">Neon Drop Puzzle</p>
            </div>
            
            <div class="text-left bg-black/20 p-6 rounded-2xl text-sm text-gray-300 border border-white/5 leading-relaxed">
                <p class="mb-3 text-white font-bold flex items-center gap-2">
                    <span class="w-1 h-4 bg-blue-500 rounded-full"></span>
                    HOW TO PLAY
                </p>
                <ul class="space-y-2 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-blue-500 mt-0.5">●</span>
                        <span>タップして数字を落とす</span>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-blue-500 mt-0.5">●</span>
                        <span>縦の合計が <strong class="text-white font-mono">10</strong> で消滅</span>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-blue-500 mt-0.5">●</span>
                        <span>連鎖で高得点を狙え</span>
                    </li>
                </ul>
            </div>

            <button id="startBtn" class="btn-primary w-full py-4 rounded-2xl text-white font-bold text-sm tracking-[0.15em] uppercase shadow-lg hover:scale-[1.02] transition-transform">
                System Start
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-20 bg-black/80 backdrop-blur-md transition-all duration-500">
        <div class="glass-panel p-10 rounded-3xl max-w-xs w-full text-center space-y-8 border-t border-red-500/20 shadow-red-900/20 shadow-2xl">
            <div class="text-red-500 font-bold tracking-[0.3em] text-sm uppercase animate-pulse">Game Over</div>
            <div>
                <div class="text-[10px] text-gray-500 uppercase tracking-widest mb-2">Final Score</div>
                <div id="finalScore" class="text-6xl font-bold text-white font-['JetBrains_Mono'] tracking-tighter text-shadow-lg">0</div>
            </div>
            <button id="restartBtn" class="btn-primary w-full py-4 rounded-2xl text-white font-bold text-sm tracking-[0.15em] uppercase hover:scale-[1.02]">
                Reboot
            </button>
        </div>
    </div>

    <script>
        /**
         * MAKE 10: NEON DROP (High-Res Edition)
         */

        const COLS = 6;
        const ROWS = 10;
        // Colors updated for a more sophisticated look
        const COLORS = {
            bg: '#050505',
            grid: 'rgba(255, 255, 255, 0.03)',
            gridBorder: 'rgba(255, 255, 255, 0.05)',
            text: '#ffffff',
            // Palette: Red, Orange, Yellow, Green, Cyan, Blue, Purple, Magenta, Pink
            palette: [
                '#ff3b30', // 1 Red
                '#ff9500', // 2 Orange
                '#ffcc00', // 3 Yellow
                '#30d158', // 4 Green
                '#64d2ff', // 5 Cyan
                '#0a84ff', // 6 Blue
                '#5e5ce6', // 7 Indigo
                '#bf5af2', // 8 Purple
                '#ff375f', // 9 Pink
            ]
        };

        class AudioManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.2; // Slightly quieter
                this.masterGain.connect(this.ctx.destination);
            }

            playTone(freq, type, duration, delay = 0, vol = 0.5) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + delay);
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime + delay);
                gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + delay + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(this.ctx.currentTime + delay);
                osc.stop(this.ctx.currentTime + delay + duration);
            }

            playDrop() { this.playTone(400, 'sine', 0.15, 0, 0.3); }
            playStack() { this.playTone(200, 'triangle', 0.1); }
            playClear() { 
                // Major chord arpeggio
                this.playTone(523.25, 'sine', 0.3, 0);   // C5
                this.playTone(659.25, 'sine', 0.3, 0.05); // E5
                this.playTone(783.99, 'sine', 0.4, 0.1);  // G5
                this.playTone(1046.50, 'sine', 0.6, 0.15); // C6
            }
            playGameOver() {
                this.playTone(150, 'sawtooth', 0.8, 0, 0.4);
                this.playTone(100, 'sawtooth', 0.8, 0.2, 0.4);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 6 + 4; // Larger for high res
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life -= this.decay;
                this.size *= 0.92;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.globalCompositeOperation = 'lighter'; // Additive blending for neon look
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false }); // Optimize
                this.audio = new AudioManager();
                
                this.grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                this.particles = [];
                this.score = 0;
                this.isPlaying = false;
                
                this.fallingPieces = []; 
                this.nextPieceVal = this.randomNum();

                // Resize handling including High DPI support
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.canvas.addEventListener('pointerdown', (e) => this.handleInput(e));

                this.lastTime = 0;
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            resize() {
                // --- High DPI (Retina) Support ---
                const dpr = window.devicePixelRatio || 1;
                
                // 1. Get display size (CSS pixels)
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;

                // 2. Set canvas buffer size (Physical pixels)
                this.canvas.width = Math.floor(displayWidth * dpr);
                this.canvas.height = Math.floor(displayHeight * dpr);

                // 3. Set canvas CSS size
                this.canvas.style.width = `${displayWidth}px`;
                this.canvas.style.height = `${displayHeight}px`;

                // 4. Normalize coordinate system to CSS pixels
                this.ctx.resetTransform(); // Reset first
                this.ctx.scale(dpr, dpr);

                // --- Grid Calculation (Logical Coordinates) ---
                const availableHeight = displayHeight - 140; // More space for HUD
                const availableWidth = displayWidth - 30;
                
                const maxCellH = availableHeight / ROWS;
                const maxCellW = availableWidth / COLS;
                
                this.cellWidth = Math.min(maxCellW, maxCellH, 65);
                this.cellHeight = this.cellWidth;

                const gridPixelWidth = this.cellWidth * COLS;
                const gridPixelHeight = this.cellHeight * ROWS;
                
                this.gridOffsetX = (displayWidth - gridPixelWidth) / 2;
                this.gridOffsetY = Math.max((displayHeight - gridPixelHeight) / 2 + 30, 100);
            }

            reset() {
                this.resize();
                this.grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                this.score = 0;
                this.particles = [];
                this.fallingPieces = [];
                this.nextPieceVal = this.randomNum();
                this.updateUI();
                this.isPlaying = true;
            }

            randomNum() {
                return Math.floor(Math.random() * 9) + 1;
            }

            getColFromX(x) {
                const relativeX = x - this.gridOffsetX;
                const col = Math.floor(relativeX / this.cellWidth);
                return (col >= 0 && col < COLS) ? col : -1;
            }

            handleInput(e) {
                if (!this.isPlaying) return;
                const col = this.getColFromX(e.clientX);
                if (col === -1) return;

                // Top row full check
                if (this.grid[0] && this.grid[0][col] !== null) return; 

                this.spawnPieceInColumn(col, this.nextPieceVal);
                this.nextPieceVal = this.randomNum();
                this.updateUI();
                this.audio.playDrop();
            }

            spawnPieceInColumn(col, val) {
                let staticTargetRow = ROWS - 1;
                for (let r = 0; r < ROWS; r++) {
                    if (this.grid[r][col] !== null) {
                        staticTargetRow = r - 1;
                        break;
                    }
                }

                let finalTargetRow = staticTargetRow;
                for (let p of this.fallingPieces) {
                    if (p.col === col) {
                        if (p.targetRow <= finalTargetRow) {
                            finalTargetRow = p.targetRow - 1;
                        }
                    }
                }

                if (finalTargetRow < 0) {
                    this.gameOver();
                    return;
                }

                const targetPixelY = this.gridOffsetY + (finalTargetRow * this.cellHeight);

                this.fallingPieces.push({
                    col: col,
                    targetRow: finalTargetRow,
                    val: val,
                    y: this.gridOffsetY - this.cellHeight,
                    targetY: targetPixelY,
                    speed: 0,
                    landed: false
                });
            }

            update(dt) {
                if (!this.isPlaying) return;

                for (let i = this.fallingPieces.length - 1; i >= 0; i--) {
                    let p = this.fallingPieces[i];
                    p.speed += 1.8; // Stronger gravity feeling
                    p.y += p.speed;

                    const floorLimit = this.gridOffsetY + (ROWS - 1) * this.cellHeight;
                    let hit = false;

                    if (p.y >= p.targetY) hit = true;
                    if (p.y > floorLimit && p.targetRow === ROWS - 1) {
                        hit = true; 
                        p.y = p.targetY;
                    }

                    if (hit) {
                        p.y = p.targetY;
                        p.landed = true;
                        
                        if (this.grid[p.targetRow]) {
                            this.grid[p.targetRow][p.col] = { val: p.val, color: this.getColor(p.val) };
                            this.checkMatch(p.targetRow, p.col);
                        }
                        this.fallingPieces.splice(i, 1);
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }
            }

            checkMatch(row, col) {
                if (row < ROWS - 1) {
                    const below = this.grid[row + 1][col];
                    if (below) {
                        const current = this.grid[row][col];
                        const sum = current.val + below.val;

                        if (sum === 10) {
                            setTimeout(() => {
                                this.createExplosion(col, row, this.getColor(current.val));
                                this.createExplosion(col, row + 1, this.getColor(below.val));
                                
                                this.grid[row][col] = null;
                                this.grid[row + 1][col] = null;
                                this.score += 100;
                                this.updateUI();
                                this.audio.playClear();
                                this.applyGravity(col);
                            }, 60); 
                        } else {
                            this.audio.playStack();
                            if (row === 0) this.gameOver();
                        }
                    } else {
                         this.audio.playStack();
                    }
                } else {
                    this.audio.playStack();
                }
            }

            applyGravity(col) {
                let writePtr = ROWS - 1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (this.grid[r][col] !== null) {
                        if (writePtr !== r) {
                            this.grid[writePtr][col] = this.grid[r][col];
                            this.grid[r][col] = null;
                            
                             if (writePtr < ROWS - 1 && this.grid[writePtr + 1][col]) {
                                if (this.grid[writePtr][col].val + this.grid[writePtr + 1][col].val === 10) {
                                    // Chain reaction simplified
                                }
                            }
                        }
                        writePtr--;
                    }
                }
            }

            createExplosion(c, r, color) {
                const x = this.gridOffsetX + c * this.cellWidth + this.cellWidth / 2;
                const y = this.gridOffsetY + r * this.cellHeight + this.cellHeight / 2;
                for (let i = 0; i < 20; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            gameOver() {
                this.isPlaying = false;
                this.audio.playGameOver();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }

            updateUI() {
                const scoreEl = document.getElementById('scoreDisplay');
                // Number scramble animation
                let current = parseInt(scoreEl.innerText);
                if (current !== this.score) {
                    scoreEl.innerText = this.score;
                    scoreEl.style.transform = 'scale(1.2)';
                    scoreEl.style.color = '#64d2ff';
                    setTimeout(() => {
                        scoreEl.style.transform = 'scale(1)';
                        scoreEl.style.color = 'white';
                    }, 100);
                }

                this.nextPieceVal = this.nextPieceVal || this.randomNum();
                const nextPiece = document.getElementById('nextPieceDisplay');
                nextPiece.innerText = this.nextPieceVal;
                const color = this.getColor(this.nextPieceVal);
                nextPiece.style.color = color;
                nextPiece.style.borderColor = color;
                nextPiece.style.boxShadow = `0 0 20px ${color}40`;
            }

            getColor(num) {
                return COLORS.palette[num - 1] || '#fff';
            }

            // --- High Quality Rendering ---
            draw() {
                // Background
                this.ctx.fillStyle = COLORS.bg;
                this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight); // Use logical size for fillRect as we scaled ctx

                // Grid Container (Glass look)
                const boardH = ROWS * this.cellHeight;
                const boardW = COLS * this.cellWidth;
                
                this.ctx.fillStyle = 'rgba(20, 20, 30, 0.5)';
                this.ctx.roundRect(this.gridOffsetX - 4, this.gridOffsetY - 4, boardW + 8, boardH + 8, 12);
                this.ctx.fill();
                this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Draw Grid Lines
                this.ctx.beginPath();
                this.ctx.strokeStyle = COLORS.grid;
                this.ctx.lineWidth = 1;
                for (let c = 1; c < COLS; c++) {
                    const x = this.gridOffsetX + c * this.cellWidth;
                    this.ctx.moveTo(x, this.gridOffsetY);
                    this.ctx.lineTo(x, this.gridOffsetY + boardH);
                }
                for (let r = 1; r < ROWS; r++) {
                    const y = this.gridOffsetY + r * this.cellHeight;
                    this.ctx.moveTo(this.gridOffsetX, y);
                    this.ctx.lineTo(this.gridOffsetX + boardW, y);
                }
                this.ctx.stroke();

                const drawCell = (val, r, c, yPixel = null) => {
                    const x = this.gridOffsetX + c * this.cellWidth;
                    const y = yPixel !== null ? yPixel : this.gridOffsetY + r * this.cellHeight;
                    
                    const size = this.cellWidth * 0.85;
                    const margin = (this.cellWidth - size) / 2;
                    const color = this.getColor(val);

                    // --- Sophisticated Block Rendering ---
                    
                    // 1. Outer Glow
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = color;
                    
                    // 2. Main Body (Gradient)
                    const grad = this.ctx.createLinearGradient(x, y, x, y + size);
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, adjustColor(color, -40)); // Darken bottom

                    this.ctx.fillStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.roundRect(x + margin, y + margin, size, size, 10);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0; // Reset shadow for crisp details

                    // 3. Inner Gloss (Top highlight)
                    this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    this.ctx.beginPath();
                    this.ctx.ellipse(x + this.cellWidth/2, y + margin + size*0.2, size*0.6, size*0.2, 0, 0, Math.PI * 2);
                    this.ctx.fill();

                    // 4. Text
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = `bold ${size * 0.5}px 'JetBrains Mono', monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    // Text shadow for readability
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 4;
                    this.ctx.fillText(val, x + this.cellWidth/2, y + this.cellHeight/2 + 2);
                    this.ctx.shadowBlur = 0;
                };

                // Helper for gradient
                function adjustColor(color, amount) {
                    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
                }

                // Draw Static Grid
                if (this.grid && this.grid.length === ROWS) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (this.grid[r][c]) {
                                drawCell(this.grid[r][c].val, r, c);
                            }
                        }
                    }
                }

                // Draw Falling Pieces
                for (let p of this.fallingPieces) {
                    drawCell(p.val, -1, p.col, p.y);
                }

                // Particles
                for (let p of this.particles) {
                    p.draw(this.ctx);
                }
            }

            animate(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(dt);
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        // --- Init ---
        const game = new Game();

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('startScreen').style.opacity = 0;
            document.getElementById('startScreen').style.pointerEvents = 'none';
            game.audio.ctx.resume();
            game.reset();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            game.reset();
        });

        // Polyfill for roundRect if needed (modern browsers support it)
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

    </script>
</body>
</html>
