<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Make 10</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@700&display=swap');

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #050505;
            color: #ffffff;
            overflow: hidden;
            touch-action: none;
            background: radial-gradient(circle at 50% 10%, #1a1a2e 0%, #000000 100%);
            -webkit-tap-highlight-color: transparent;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2997ff, #005ecb);
            box-shadow: 0 0 20px rgba(41, 151, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            position: relative;
            overflow: hidden;
        }
        .btn-primary:after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(255,255,255,0.2), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .btn-primary:active {
            transform: scale(0.94);
            box-shadow: 0 0 10px rgba(41, 151, 255, 0.1);
        }
        .btn-primary:active:after {
            opacity: 1;
        }
        
        .neon-text {
            text-shadow: 0 0 10px rgba(255,255,255,0.5), 0 0 20px rgba(41, 151, 255, 0.3);
        }
        
        @keyframes pulse-target {
            0% { transform: scale(1); text-shadow: 0 0 10px rgba(250, 204, 21, 0.5); }
            50% { transform: scale(1.2); text-shadow: 0 0 20px rgba(250, 204, 21, 0.8), 0 0 40px rgba(250, 204, 21, 0.4); }
            100% { transform: scale(1); text-shadow: 0 0 10px rgba(250, 204, 21, 0.5); }
        }
        .target-change-anim {
            animation: pulse-target 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Target Change Overlay Animation */
        @keyframes pop-in-out {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            15% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
        }
        .overlay-anim {
            animation: pop-in-out 2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Target Change Overlay (Hidden by default) -->
    <div id="targetChangeOverlay" class="hidden fixed top-1/2 left-1/2 w-full pointer-events-none z-50 text-center">
        <div class="text-yellow-400 font-black italic tracking-tighter text-4xl md:text-6xl mb-2 drop-shadow-[0_0_15px_rgba(250,204,21,0.8)]" style="text-shadow: 0 0 30px orange;">TARGET CHANGE</div>
        <div id="overlayTargetNum" class="text-white font-['JetBrains_Mono'] font-bold text-8xl md:text-9xl drop-shadow-2xl neon-text">15</div>
    </div>

    <!-- HUD -->
    <div id="hud" class="absolute top-0 left-0 w-full p-4 md:p-6 flex justify-between items-start pointer-events-none z-10 select-none bg-transparent">
        <!-- Score & Best -->
        <div class="flex flex-col gap-2 w-24 bg-transparent">
            <div>
                <div class="text-[10px] text-gray-400 tracking-[0.2em] font-bold uppercase opacity-70">SCORE</div>
                <div id="scoreDisplay" class="text-2xl md:text-3xl font-bold text-white tabular-nums font-['JetBrains_Mono'] tracking-tighter neon-text">0</div>
            </div>
            <div>
                <div class="text-[10px] text-blue-400 tracking-[0.2em] font-bold uppercase opacity-80">BEST</div>
                <div id="bestScoreDisplay" class="text-lg font-bold text-blue-200 tabular-nums font-['JetBrains_Mono'] tracking-tighter">0</div>
            </div>
        </div>

        <!-- Target Display (Center) -->
        <div class="flex flex-col gap-1 items-center transform translate-y-[-5px] bg-transparent">
            <div class="text-[10px] text-yellow-500/80 tracking-[0.3em] font-bold uppercase">TARGET</div>
            <div id="targetDisplay" class="text-5xl md:text-6xl font-black text-yellow-400 tabular-nums font-['JetBrains_Mono'] tracking-tighter drop-shadow-2xl" style="text-shadow: 0 0 30px rgba(250, 204, 21, 0.4);">10</div>
        </div>

        <!-- Next Piece -->
        <div class="flex flex-col gap-2 items-end w-24 bg-transparent">
            <div class="text-[10px] text-gray-400 tracking-[0.2em] font-bold uppercase opacity-70">NEXT</div>
            <div class="relative">
                <div class="absolute inset-0 bg-blue-500/20 blur-xl rounded-full"></div>
                <div id="nextPieceDisplay" class="relative w-12 h-12 rounded-xl bg-white/5 border border-white/10 flex items-center justify-center text-2xl font-bold text-white shadow-2xl backdrop-blur-md">
                </div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-20 bg-black/60 backdrop-blur-sm transition-all duration-500">
        <div class="glass-panel p-10 rounded-3xl max-w-sm w-full text-center space-y-8 m-4 border-t border-white/10">
            <div class="space-y-2">
                <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-br from-white to-gray-500 tracking-tight drop-shadow-lg">MAKE 10</h1>
                <div class="h-1 w-12 bg-blue-500 mx-auto rounded-full opacity-80"></div>
                <p class="text-gray-400 text-xs tracking-widest uppercase pt-2">Dynamic Target Edition</p>
            </div>
            
            <div class="text-left bg-black/20 p-6 rounded-2xl text-sm text-gray-300 border border-white/5 leading-relaxed">
                <p class="mb-3 text-white font-bold flex items-center gap-2">
                    <span class="w-1 h-4 bg-blue-500 rounded-full"></span>
                    MISSION
                </p>
                <ul class="space-y-3 text-xs text-gray-400">
                    <li class="flex items-start gap-2">
                        <span class="text-blue-500 mt-0.5 text-base">●</span>
                        <span>数字を落として積み上げる</span>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-yellow-500 mt-0.5 text-base">●</span>
                        <span>縦に並んだ合計が <strong class="text-yellow-400 text-sm font-mono">TARGET</strong> になると消滅</span>
                    </li>
                    <li class="flex items-start gap-2">
                        <span class="text-red-500 mt-0.5 text-base">●</span>
                        <span>枠からはみ出すとゲームオーバー！</span>
                    </li>
                </ul>
            </div>

            <button id="startBtn" class="btn-primary w-full py-4 rounded-2xl text-white font-bold text-sm tracking-[0.15em] uppercase shadow-lg hover:scale-[1.02] transition-transform">
                System Start
            </button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-20 bg-black/80 backdrop-blur-md transition-all duration-500">
        <div class="glass-panel p-10 rounded-3xl max-w-xs w-full text-center space-y-8 border-t border-red-500/20 shadow-red-900/20 shadow-2xl">
            <div class="text-red-500 font-bold tracking-[0.3em] text-sm uppercase animate-pulse">Game Over</div>
            <div>
                <div class="text-[10px] text-gray-500 uppercase tracking-widest mb-2">Final Score</div>
                <div id="finalScore" class="text-6xl font-bold text-white font-['JetBrains_Mono'] tracking-tighter text-shadow-lg">0</div>
                <div class="mt-4 text-sm text-blue-300 font-mono">BEST: <span id="gameOverBest">0</span></div>
            </div>
            <button id="restartBtn" class="btn-primary w-full py-4 rounded-2xl text-white font-bold text-sm tracking-[0.15em] uppercase hover:scale-[1.02]">
                Reboot
            </button>
        </div>
    </div>

    <script>
        /**
         * MAKE 10: NEON DROP (v2.3 - Best Score & Enhanced UX)
         */

        const COLS = 6;
        const ROWS = 10;
        const COLORS = {
            bg: '#050505',
            grid: 'rgba(255, 255, 255, 0.03)',
            gridBorder: 'rgba(255, 255, 255, 0.05)',
            text: '#ffffff',
            palette: [
                '#ff3b30', '#ff9500', '#ffcc00', '#30d158', '#64d2ff', 
                '#0a84ff', '#5e5ce6', '#bf5af2', '#ff375f'
            ]
        };

        class AudioManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.2;
                this.masterGain.connect(this.ctx.destination);
            }

            playTone(freq, type, duration, delay = 0, vol = 0.5) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + delay);
                gain.gain.setValueAtTime(0, this.ctx.currentTime + delay);
                gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + delay + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(this.ctx.currentTime + delay);
                osc.stop(this.ctx.currentTime + delay + duration);
            }

            playDrop() { this.playTone(400, 'sine', 0.15, 0, 0.3); }
            playStack() { this.playTone(200, 'triangle', 0.1); }
            playClear() { 
                this.playTone(523.25, 'sine', 0.3, 0);   
                this.playTone(659.25, 'sine', 0.3, 0.05); 
                this.playTone(783.99, 'sine', 0.4, 0.1);  
                this.playTone(1046.50, 'sine', 0.6, 0.15); 
            }
            playTargetChange() {
                this.playTone(800, 'sine', 0.3, 0, 0.4);
                this.playTone(1200, 'square', 0.5, 0.1, 0.2);
            }
            playGameOver() {
                this.playTone(150, 'sawtooth', 0.8, 0, 0.4);
                this.playTone(100, 'sawtooth', 0.8, 0.2, 0.4);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 6 + 4;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                this.life -= this.decay;
                this.size *= 0.92;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.audio = new AudioManager();
                
                this.grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                this.particles = [];
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('neonDropBest')) || 0;
                this.targetSum = 10;
                this.lastLevel = 0;
                this.isPlaying = false;
                
                this.fallingPieces = []; 
                this.nextPieceVal = this.randomNum();

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('pointerdown', (e) => this.handleInput(e));

                this.lastTime = 0;
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
                
                // Init best score display
                document.getElementById('bestScoreDisplay').innerText = this.bestScore;
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;
                this.canvas.width = Math.floor(displayWidth * dpr);
                this.canvas.height = Math.floor(displayHeight * dpr);
                this.canvas.style.width = `${displayWidth}px`;
                this.canvas.style.height = `${displayHeight}px`;
                this.ctx.resetTransform();
                this.ctx.scale(dpr, dpr);

                const availableHeight = displayHeight - 160; 
                const availableWidth = displayWidth - 30;
                const maxCellH = availableHeight / ROWS;
                const maxCellW = availableWidth / COLS;
                this.cellWidth = Math.min(maxCellW, maxCellH, 65);
                this.cellHeight = this.cellWidth;

                const gridPixelWidth = this.cellWidth * COLS;
                const gridPixelHeight = this.cellHeight * ROWS;
                this.gridOffsetX = (displayWidth - gridPixelWidth) / 2;
                this.gridOffsetY = Math.max((displayHeight - gridPixelHeight) / 2 + 40, 120);
            }

            reset() {
                this.resize();
                this.grid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
                this.score = 0;
                this.targetSum = 10; 
                this.lastLevel = 0;
                this.particles = [];
                this.fallingPieces = [];
                this.nextPieceVal = this.randomNum();
                
                this.initializeRandomRows(2);

                this.updateUI();
                this.isPlaying = true;
            }

            initializeRandomRows(rowCount) {
                for (let r = ROWS - 1; r >= ROWS - rowCount; r--) {
                    for (let c = 0; c < COLS; c++) {
                        let safe = false;
                        let val;
                        let attempts = 0;
                        while (!safe && attempts < 50) {
                            val = this.randomNum();
                            safe = true;
                            if (val === this.targetSum) safe = false;
                            if (r < ROWS - 1) {
                                const below = this.grid[r + 1][c];
                                if (below && (val + below.val === this.targetSum)) {
                                    safe = false;
                                }
                            }
                            attempts++;
                        }
                        this.grid[r][c] = { val: val, color: this.getColor(val), isClearing: false };
                    }
                }
            }

            randomNum() {
                return Math.floor(Math.random() * 9) + 1;
            }

            getColFromX(x) {
                const relativeX = x - this.gridOffsetX;
                const col = Math.floor(relativeX / this.cellWidth);
                return (col >= 0 && col < COLS) ? col : -1;
            }

            getTopRowIndex(col) {
                for (let r = 0; r < ROWS; r++) {
                    if (this.grid[r][col] !== null) return r;
                }
                return ROWS;
            }

            handleInput(e) {
                if (!this.isPlaying) return;
                const col = this.getColFromX(e.clientX);
                if (col === -1) return;
                
                // Check Game Over Condition: If column is full to the top
                if (this.grid[0][col] !== null) {
                    // Trigger Game Over immediately if tapping a full column
                    this.gameOver();
                    return; 
                }

                this.spawnPieceInColumn(col, this.nextPieceVal);
                this.nextPieceVal = this.randomNum();
                this.updateUI();
                this.audio.playDrop();
            }

            spawnPieceInColumn(col, val) {
                this.fallingPieces.push({
                    col: col,
                    val: val,
                    y: this.gridOffsetY - this.cellHeight,
                    speed: 0,
                    landed: false
                });
            }

            update(dt) {
                if (!this.isPlaying) return;

                for (let i = this.fallingPieces.length - 1; i >= 0; i--) {
                    let p = this.fallingPieces[i];
                    p.speed += 1.8;
                    p.y += p.speed;

                    let floorIndex = this.getTopRowIndex(p.col);
                    let targetRow = floorIndex - 1;
                    
                    let piecesBelow = 0;
                    for (let j = 0; j < this.fallingPieces.length; j++) {
                        if (i === j) continue;
                        const other = this.fallingPieces[j];
                        if (other.col === p.col && other.y > p.y) {
                            piecesBelow++;
                        }
                    }
                    targetRow -= piecesBelow;
                    
                    const targetPixelY = this.gridOffsetY + (targetRow * this.cellHeight);
                    
                    if (p.y >= targetPixelY) {
                        // Strict Game Over check: landed outside top
                        if (targetRow < 0) {
                            this.gameOver();
                            return;
                        }

                        p.y = targetPixelY;
                        p.landed = true;
                        this.grid[targetRow][p.col] = { val: p.val, color: this.getColor(p.val), isClearing: false };
                        this.checkMatch(p.col);
                        this.fallingPieces.splice(i, 1);
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }
            }

            checkMatch(col) {
                let stack = [];
                for (let r = 0; r < ROWS; r++) {
                    if (this.grid[r][col] !== null && !this.grid[r][col].isClearing) {
                        stack.push({ val: this.grid[r][col].val, r: r });
                    }
                }

                let matchFound = false;
                let matchIndices = [];

                outerLoop:
                for (let i = 0; i < stack.length; i++) {
                    let currentSum = 0;
                    let currentIndices = [];
                    for (let j = i; j < stack.length; j++) {
                        currentSum += stack[j].val;
                        currentIndices.push(stack[j].r);

                        if (currentSum === this.targetSum) {
                            matchFound = true;
                            matchIndices = currentIndices;
                            break outerLoop;
                        }
                        if (currentSum > this.targetSum) break;
                    }
                }

                if (matchFound) {
                    matchIndices.forEach(r => {
                        if(this.grid[r][col]) this.grid[r][col].isClearing = true;
                    });

                    setTimeout(() => {
                        matchIndices.forEach(r => {
                            if (this.grid[r][col]) {
                                const cellVal = this.grid[r][col].val;
                                this.createExplosion(col, r, this.getColor(cellVal));
                                this.grid[r][col] = null;
                            }
                        });

                        this.score += 100 * matchIndices.length;
                        
                        // Update Best Score realtime
                        if (this.score > this.bestScore) {
                            this.bestScore = this.score;
                            document.getElementById('bestScoreDisplay').innerText = this.bestScore;
                        }

                        this.checkLevelProgression();
                        this.updateUI();
                        this.audio.playClear();
                        this.applyGravity(col);
                    }, 60);
                }
            }

            checkLevelProgression() {
                const levelStep = 1500;
                const currentLevel = Math.floor(this.score / levelStep);

                if (currentLevel > this.lastLevel) {
                    this.lastLevel = currentLevel;
                    this.changeTarget();
                }
            }

            changeTarget() {
                const minT = 10; 
                const maxT = 19;
                
                let newTarget = this.targetSum;
                while (newTarget === this.targetSum) {
                    newTarget = Math.floor(Math.random() * (maxT - minT + 1)) + minT;
                }
                
                this.targetSum = newTarget;
                this.audio.playTargetChange();

                // Trigger Big Overlay Animation
                const overlay = document.getElementById('targetChangeOverlay');
                const overlayNum = document.getElementById('overlayTargetNum');
                overlayNum.innerText = this.targetSum;
                
                overlay.classList.remove('hidden');
                overlay.classList.remove('overlay-anim');
                void overlay.offsetWidth; // Reflow
                overlay.classList.add('overlay-anim');

                // Regular HUD Animation
                const targetEl = document.getElementById('targetDisplay');
                targetEl.classList.remove('target-change-anim');
                void targetEl.offsetWidth;
                targetEl.classList.add('target-change-anim');
                
                targetEl.style.color = '#fff';
                setTimeout(() => { targetEl.style.color = '#facc15'; }, 300);

                this.checkAllColumnsMatches();
            }

            checkAllColumnsMatches() {
                for (let c = 0; c < COLS; c++) {
                    this.checkMatch(c);
                }
            }

            applyGravity(col) {
                let pieces = [];
                for (let r = 0; r < ROWS; r++) {
                    if (this.grid[r][col] !== null) {
                        pieces.push(this.grid[r][col]);
                        this.grid[r][col] = null;
                    }
                }

                let writeRow = ROWS - 1;
                for (let i = pieces.length - 1; i >= 0; i--) {
                    this.grid[writeRow][col] = pieces[i];
                    writeRow--;
                }

                if (pieces.length > 0) {
                     setTimeout(() => {
                         this.checkMatch(col);
                     }, 150);
                }
            }

            createExplosion(c, r, color) {
                const x = this.gridOffsetX + c * this.cellWidth + this.cellWidth / 2;
                const y = this.gridOffsetY + r * this.cellHeight + this.cellHeight / 2;
                for (let i = 0; i < 20; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            gameOver() {
                if (!this.isPlaying) return;
                this.isPlaying = false;
                
                // Save Best Score
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                }
                localStorage.setItem('neonDropBest', this.bestScore);
                
                this.audio.playGameOver();
                document.getElementById('finalScore').innerText = this.score;
                document.getElementById('gameOverBest').innerText = this.bestScore;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }

            updateUI() {
                const scoreEl = document.getElementById('scoreDisplay');
                const targetEl = document.getElementById('targetDisplay');
                
                let current = parseInt(scoreEl.innerText);
                if (current !== this.score) {
                    scoreEl.innerText = this.score;
                    scoreEl.style.transform = 'scale(1.2)';
                    scoreEl.style.color = '#64d2ff';
                    setTimeout(() => {
                        scoreEl.style.transform = 'scale(1)';
                        scoreEl.style.color = 'white';
                    }, 100);
                }

                if (parseInt(targetEl.innerText) !== this.targetSum) {
                    targetEl.innerText = this.targetSum;
                }

                this.nextPieceVal = this.nextPieceVal || this.randomNum();
                const nextPiece = document.getElementById('nextPieceDisplay');
                nextPiece.innerText = this.nextPieceVal;
                const color = this.getColor(this.nextPieceVal);
                nextPiece.style.color = color;
                nextPiece.style.borderColor = color;
                nextPiece.style.boxShadow = `0 0 20px ${color}40`;
            }

            getColor(num) {
                return COLORS.palette[num - 1] || '#fff';
            }

            draw() {
                this.ctx.fillStyle = COLORS.bg;
                this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

                const boardH = ROWS * this.cellHeight;
                const boardW = COLS * this.cellWidth;
                
                this.ctx.fillStyle = 'rgba(20, 20, 30, 0.5)';
                this.ctx.roundRect(this.gridOffsetX - 4, this.gridOffsetY - 4, boardW + 8, boardH + 8, 12);
                this.ctx.fill();
                this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.strokeStyle = COLORS.grid;
                this.ctx.lineWidth = 1;
                for (let c = 1; c < COLS; c++) {
                    const x = this.gridOffsetX + c * this.cellWidth;
                    this.ctx.moveTo(x, this.gridOffsetY);
                    this.ctx.lineTo(x, this.gridOffsetY + boardH);
                }
                for (let r = 1; r < ROWS; r++) {
                    const y = this.gridOffsetY + r * this.cellHeight;
                    this.ctx.moveTo(this.gridOffsetX, y);
                    this.ctx.lineTo(this.gridOffsetX + boardW, y);
                }
                this.ctx.stroke();

                const drawCell = (val, r, c, yPixel = null, isClearing = false) => {
                    const x = this.gridOffsetX + c * this.cellWidth;
                    const y = yPixel !== null ? yPixel : this.gridOffsetY + r * this.cellHeight;
                    const size = this.cellWidth * 0.85;
                    const margin = (this.cellWidth - size) / 2;
                    const color = this.getColor(val);

                    if (isClearing) {
                        this.ctx.globalAlpha = 0.5;
                        this.ctx.fillStyle = '#fff';
                    } else {
                        this.ctx.globalAlpha = 1.0;
                    }

                    this.ctx.shadowBlur = isClearing ? 30 : 20;
                    this.ctx.shadowColor = color;
                    const grad = this.ctx.createLinearGradient(x, y, x, y + size);
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, adjustColor(color, -40));

                    if (!isClearing) this.ctx.fillStyle = grad;
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(x + margin, y + margin, size, size, 10);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;

                    if (!isClearing) {
                        this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        this.ctx.beginPath();
                        this.ctx.ellipse(x + this.cellWidth/2, y + margin + size*0.2, size*0.6, size*0.2, 0, 0, Math.PI * 2);
                        this.ctx.fill();
                    }

                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = `bold ${size * 0.5}px 'JetBrains Mono', monospace`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    this.ctx.shadowBlur = 4;
                    this.ctx.fillText(val, x + this.cellWidth/2, y + this.cellHeight/2 + 2);
                    this.ctx.shadowBlur = 0;
                    this.ctx.globalAlpha = 1.0;
                };

                function adjustColor(color, amount) {
                    return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
                }

                if (this.grid && this.grid.length === ROWS) {
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (this.grid[r][c]) {
                                drawCell(this.grid[r][c].val, r, c, null, this.grid[r][c].isClearing);
                            }
                        }
                    }
                }

                for (let p of this.fallingPieces) {
                    drawCell(p.val, -1, p.col, p.y);
                }

                for (let p of this.particles) {
                    p.draw(this.ctx);
                }
            }

            animate(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(dt);
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        const game = new Game();

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('startScreen').style.opacity = 0;
            document.getElementById('startScreen').style.pointerEvents = 'none';
            game.audio.ctx.resume();
            game.reset();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            game.reset();
        });

        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }
    </script>
</body>
</html>
