<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê¨°‰∏ñ‰ª£„Åó„Çä„Å®„Çä - NG Word Battle</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PeerJS (WebRTC Wrapper) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&display=swap');
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .animate-pop {
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .hp-dot {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Utils ---
        const generateId = () => Math.random().toString(36).substring(2, 6).toUpperCase();

        const toHiragana = (str) => {
            return str.replace(/[\u30a1-\u30f6]/g, match => {
                const chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        };

        const getLastChar = (word) => {
            if (!word) return '';
            const last = word.slice(-1);
            // Â∞èÊñáÂ≠ó„ÅÆÂá¶ÁêÜÔºà„ÅÅ„ÅÉ„ÅÖ„Åá„Åâ„Å£„ÇÉ„ÇÖ„Çá„Çé -> „ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Å§„ÇÑ„ÇÜ„Çà„ÇèÔºâ
            const map = {'„ÅÅ':'„ÅÇ','„ÅÉ':'„ÅÑ','„ÅÖ':'„ÅÜ','„Åá':'„Åà','„Åâ':'„Åä','„Å£':'„Å§','„ÇÉ':'„ÇÑ','„ÇÖ':'„ÇÜ','„Çá':'„Çà','„Çé':'„Çè'};
            if (map[last]) return map[last];
            if (last === '„Éº') {
                // Èï∑Èü≥„ÅÆÂ†¥Âêà„ÄÅ„Åù„ÅÆÂâç„ÅÆÊñáÂ≠ó„ÅÆÊØçÈü≥„Çí„Å®„ÇãÁ∞°ÊòìÂÆüË£ÖÔºàÂé≥ÂØÜ„Å™„É´„Éº„É´„ÅØË§áÈõë„Å™„ÅÆ„ÅßÁ∞°ÊòìÂåñÔºöÂâç„ÅÆÊñáÂ≠ó„Çí„Åù„ÅÆ„Åæ„ÅæËøî„ÅôÔºâ
                const prev = word.slice(-2, -1);
                if (map[prev]) return map[prev];
                return prev;
            }
            return last;
        };

        // --- Components ---

        const Loading = () => (
            <div className="flex justify-center items-center p-4">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-400"></div>
            </div>
        );

        const Button = ({ onClick, children, className = "", disabled = false, variant = "primary" }) => {
            const baseStyle = "px-6 py-3 rounded-xl font-bold transition-all transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg";
            const variants = {
                primary: "bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white",
                danger: "bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-400 hover:to-pink-500 text-white",
                secondary: "bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600"
            };
            return (
                <button 
                    onClick={onClick} 
                    disabled={disabled}
                    className={`${baseStyle} ${variants[variant]} ${className}`}
                >
                    {children}
                </button>
            );
        };

        const InputField = ({ value, onChange, placeholder, onKeyDown, autoFocus }) => (
            <input
                type="text"
                value={value}
                onChange={onChange}
                onKeyDown={onKeyDown}
                placeholder={placeholder}
                autoFocus={autoFocus}
                className="w-full bg-slate-800/50 border-2 border-slate-600 focus:border-cyan-400 text-white px-4 py-3 rounded-xl outline-none transition-colors text-lg"
            />
        );

        const HPBar = ({ points, max = 3, isSelf }) => (
            <div className={`flex gap-2 ${isSelf ? 'justify-end' : 'justify-start'}`}>
                {[...Array(max)].map((_, i) => (
                    <div 
                        key={i} 
                        className={`w-8 h-8 rounded-full border-2 border-slate-600 flex items-center justify-center hp-dot ${i < points ? 'bg-gradient-to-br from-yellow-400 to-orange-500 scale-100 shadow-[0_0_10px_rgba(250,204,21,0.6)]' : 'bg-slate-800 scale-90 opacity-40'}`}
                    >
                        {i < points && <i data-lucide="zap" className="w-4 h-4 text-white fill-current"></i>}
                    </div>
                ))}
            </div>
        );

        // --- Main App ---

        const App = () => {
            const [peer, setPeer] = useState(null);
            const [conn, setConn] = useState(null);
            const [myId, setMyId] = useState('');
            const [targetId, setTargetId] = useState('');
            
            // Game State: 'lobby', 'setup', 'playing', 'result'
            const [gameState, setGameState] = useState('lobby');
            const [statusMsg, setStatusMsg] = useState('');

            // Setup Data
            const [ngWords, setNgWords] = useState({ 3: '', 2: '', 1: '' }); // My defined NG words
            const [opponentReady, setOpponentReady] = useState(false);
            const [iAmReady, setIAmReady] = useState(false);

            // Gameplay Data
            const [history, setHistory] = useState([]); // { word, player: 'me'|'opponent', damage: num, reason: str }
            const [currentTurn, setCurrentTurn] = useState('host'); // 'host' or 'guest'
            const [role, setRole] = useState(null); // 'host' or 'guest'
            const [myScore, setMyScore] = useState(0);
            const [oppScore, setOppScore] = useState(0);
            const [timer, setTimer] = useState(15);
            const [inputWord, setInputWord] = useState('');
            const [lastChar, setLastChar] = useState(''); // The character the next word must start with

            // Timer Ref
            const timerRef = useRef(null);

            // Initialize Peer
            useEffect(() => {
                const newPeer = new Peer(null, { debug: 2 });
                newPeer.on('open', (id) => {
                    setMyId(id);
                    setPeer(newPeer);
                });

                newPeer.on('connection', (connection) => {
                    setupConnection(connection, 'host');
                });

                return () => newPeer.destroy();
            }, []);

            // Lucide icons
            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            });

            // Timer Logic
            useEffect(() => {
                if (gameState === 'playing' && !checkGameOver(myScore, oppScore)) {
                    if (timerRef.current) clearInterval(timerRef.current);
                    
                    setTimer(15); // Reset timer on turn change
                    
                    timerRef.current = setInterval(() => {
                        setTimer((prev) => {
                            if (prev <= 1) {
                                clearInterval(timerRef.current);
                                handleTimeOut();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                }
                return () => clearInterval(timerRef.current);
            }, [currentTurn, gameState]);


            const setupConnection = (connection, myRole) => {
                setConn(connection);
                setRole(myRole);
                
                connection.on('open', () => {
                    setGameState('setup');
                    setStatusMsg('Êé•Á∂öÂÆå‰∫ÜÔºÅ NG„ÉØ„Éº„Éâ„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                });

                connection.on('data', (data) => {
                    handleData(data);
                });
                
                connection.on('close', () => {
                    alert('Áõ∏Êâã„Å®„ÅÆÊé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü');
                    location.reload();
                });
            };

            const joinGame = () => {
                if (!peer || !targetId) return;
                const connection = peer.connect(targetId);
                setupConnection(connection, 'guest');
            };

            const handleData = (data) => {
                console.log("Received:", data);
                
                switch (data.type) {
                    case 'READY':
                        setOpponentReady(true);
                        break;
                    case 'MOVE':
                        // Áõ∏Êâã„ÅåË®ÄËëâ„ÇíÈÄÅ„Å£„Å¶„Åç„Åü
                        // 1. „Åì„Å°„Çâ„ÅÆNG„ÉØ„Éº„Éâ„É™„Çπ„Éà„Å®ÁÖßÂêà„Åó„Å¶„ÉÄ„É°„Éº„Ç∏Âà§ÂÆö„ÇíË°å„ÅÜ
                        // 2. ÁµêÊûú„ÇíÂèåÊñπ„Å´ÂèçÊò†ÔºàDAMAGE„Ç§„Éô„É≥„Éà„ÇíÈÄÅ„ÇäËøî„Åô„Åã„ÄÅ„Åì„Åì„ÅßÂá¶ÁêÜ„Åó„Å¶ÂêåÊúü„Åô„Çã„ÅãÔºâ
                        // „Ç∑„É≥„Éó„É´„Å´„Åô„Çã„Åü„ÇÅ„ÄÅÂèó‰ø°ÂÅ¥ÔºàNG„ÉØ„Éº„Éâ„ÇíÁü•„Å£„Å¶„ÅÑ„ÇãÂÅ¥Ôºâ„ÅåÂà§ÂÆö„Åó„Å¶ÁµêÊûú„Çí„Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„Éà„Åô„Çã
                        processReceivedWord(data.word);
                        break;
                    case 'RESULT':
                        // Âà§ÂÆöÁµêÊûú„ÇíÂèó‰ø° (Ëá™ÂàÜ„ÅåÈÄÅ„Å£„ÅüË®ÄËëâ„ÅÆÁµêÊûú„ÄÅ„Åæ„Åü„ÅØ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Å™„Å©„ÅÆÈÄöÁü•)
                        applyResult(data);
                        break;
                    case 'RESTART':
                        resetGame(false);
                        break;
                }
            };

            // Setup Phase
            const handleReady = () => {
                if (!ngWords[3]) {
                    alert('ÊúÄ‰Ωé„Åß„ÇÇ„ÄåÂç≥Ê≠ªNG„ÉØ„Éº„Éâ(3pt)„Äç„ÅØË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ');
                    return;
                }
                setIAmReady(true);
                conn.send({ type: 'READY' });
            };

            // Start Game Trigger
            useEffect(() => {
                if (iAmReady && opponentReady && gameState === 'setup') {
                    setGameState('playing');
                    setLastChar(''); // Initial state, any word is fine or set a starting word?
                    // Let's create a starting word for 'host' to follow, or just 'Start free'
                    // Standard shiritori: Start with 'Shiritori' -> ends in 'ri'
                    setLastChar('„Çä'); 
                    setHistory([{ word: '„Åó„Çä„Å®„Çä', player: 'system', damage: 0 }]);
                    setCurrentTurn('host'); // Host starts first
                }
            }, [iAmReady, opponentReady, gameState]);


            // Gameplay Logic
            const processReceivedWord = (word) => {
                // Opponent sent a word. I need to check if it hits MY NG words.
                let damage = 0;
                let reasons = [];

                // 1. Check Standard NG ('N' ending) - usually sender checks, but double check
                if (getLastChar(word) === '„Çì') {
                    damage += 3;
                    reasons.push('„Äå„Çì„Äç„Åå„Å§„ÅÑ„ÅüÔºÅ(Âç≥Ê≠ª)');
                }

                // 2. Check My Trap NG Words
                if (word === ngWords[3]) {
                    damage += 3;
                    reasons.push(`‚òÖ3pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                } else if (word === ngWords[2]) {
                    damage += 2;
                    reasons.push(`‚òÖ2pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                } else if (word === ngWords[1]) {
                    damage += 1;
                    reasons.push(`‚òÖ1pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                }

                // 3. Check History (Repetition)
                const isRepeated = history.some(h => h.word === word);
                if (isRepeated) {
                    damage += 1;
                    reasons.push('Êó¢Âá∫„ÉØ„Éº„ÉâÔºÅ');
                }

                // Send result back to opponent (and self)
                const resultData = {
                    type: 'RESULT',
                    word: word,
                    player: 'opponent', // It was opponent's move
                    damage: damage,
                    reasons: reasons,
                    nextTurn: role === 'host' ? 'guest' : 'host' // Should be my turn now
                };

                conn.send(resultData);
                applyResult(resultData);
            };

            const handleSendWord = () => {
                const word = inputWord.trim();
                if (!word) return;
                
                // Basic Validation (Local)
                const hira = toHiragana(word);
                
                // Hiragana check
                if (!/^[\u3040-\u309f]+$/.test(hira)) {
                    setStatusMsg('„Å≤„Çâ„Åå„Å™„ÅÆ„ÅøÊúâÂäπ„Åß„Åô');
                    return;
                }
                // Chain check
                if (lastChar && hira.charAt(0) !== lastChar) {
                    setStatusMsg(`„Äå${lastChar}„Äç„Åã„ÇâÂßã„Åæ„ÇãË®ÄËëâ„ÇíÂÖ•„Çå„Å¶„Åè„Å†„Åï„ÅÑ`);
                    return;
                }

                // If valid, send to opponent for adjudication
                conn.send({ type: 'MOVE', word: hira });
                setInputWord('');
                setStatusMsg('Âà§ÂÆö‰∏≠...');
            };

            const handleTimeOut = () => {
                // If it's MY turn and timer runs out
                if (currentTurn === role) {
                    const resultData = {
                        type: 'RESULT',
                        word: '(ÊôÇÈñìÂàá„Çå)',
                        player: 'me', // My fault
                        damage: 1,
                        reasons: ['ÊôÇÈñìÂàá„ÇåÔºÅ'],
                        nextTurn: role === 'host' ? 'guest' : 'host'
                    };
                    conn.send(resultData);
                    applyResult(resultData);
                }
            };

            const applyResult = (data) => {
                // Update History
                setHistory(prev => [
                    { 
                        word: data.word, 
                        player: data.player === 'me' ? (role === data.player ? 'me' : 'opponent') : (role === data.player ? 'me' : 'opponent'),
                        // Logic fix: data.player is from the perspective of the sender of RESULT.
                        // If I processed the word (opponent sent it), I set player='opponent'.
                        // If I receive this RESULT, 'opponent' means the other guy.
                        isMe: (data.player === 'opponent' && role !== 'host') || (data.player === 'me' && role === 'host') ? false : true, // Simplified below
                        damage: data.damage,
                        reasons: data.reasons
                    }, 
                    ...prev
                ]);

                // Who took damage?
                // If data.player was 'opponent' (from perspective of judge), that means the person who played the word takes damage.
                // Wait, easier logic: The person whose turn it was takes damage if any.
                
                const isMyTurnWas = currentTurn === role;
                
                if (data.damage > 0) {
                     if (currentTurn === role) {
                         // I took damage
                         setOppScore(prev => Math.min(prev + data.damage, 3));
                     } else {
                         // Opponent took damage (I get points)
                         setMyScore(prev => Math.min(prev + data.damage, 3));
                     }
                }

                // Next Turn Setup
                if (data.word !== '(ÊôÇÈñìÂàá„Çå)') {
                    setLastChar(getLastChar(data.word));
                }
                
                // If game over, stop turn rotation
                const newMyScore = currentTurn !== role ? myScore + data.damage : myScore;
                const newOppScore = currentTurn === role ? oppScore + data.damage : oppScore;
                
                if (newMyScore < 3 && newOppScore < 3) {
                     setCurrentTurn(data.nextTurn);
                }
            };

            const checkGameOver = (s1, s2) => {
                return s1 >= 3 || s2 >= 3;
            };

            const resetGame = (sendSignal = true) => {
                if (sendSignal && conn) conn.send({ type: 'RESTART' });
                setMyScore(0);
                setOppScore(0);
                setHistory([{ word: '„Åó„Çä„Å®„Çä', player: 'system', damage: 0 }]);
                setLastChar('„Çä');
                setCurrentTurn('host');
                setGameState('setup'); // Go back to setup to change NG words
                setIAmReady(false);
                setOpponentReady(false);
                setNgWords({ 3: '', 2: '', 1: '' });
            };


            // --- Render Helpers ---

            const renderLobby = () => (
                <div className="max-w-md mx-auto space-y-8 animate-pop">
                    <div className="text-center space-y-2">
                        <h1 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                            NG WORD BATTLE
                        </h1>
                        <p className="text-slate-400">Ê¨°‰∏ñ‰ª£„Åó„Çä„Å®„Çä P2P</p>
                    </div>

                    <div className="glass-panel p-6 rounded-2xl space-y-4">
                        <h2 className="text-xl font-bold text-cyan-400 flex items-center gap-2">
                            <i data-lucide="user-plus"></i> ÈÉ®Â±ã„Çí‰Ωú„Çã („Éõ„Çπ„Éà)
                        </h2>
                        <div className="bg-slate-900/50 p-4 rounded-xl flex items-center justify-between border border-slate-700">
                            <code className="text-xl font-mono text-white tracking-widest">{myId || 'ÁîüÊàê‰∏≠...'}</code>
                            <button 
                                onClick={() => navigator.clipboard.writeText(myId)}
                                className="p-2 hover:bg-slate-700 rounded-lg transition-colors text-slate-400 hover:text-white"
                                title="ID„Çí„Ç≥„Éî„Éº"
                            >
                                <i data-lucide="copy"></i>
                            </button>
                        </div>
                        <p className="text-sm text-slate-500">„Åì„ÅÆID„ÇíÂèãÈÅî„Å´Êïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    </div>

                    <div className="glass-panel p-6 rounded-2xl space-y-4">
                        <h2 className="text-xl font-bold text-pink-400 flex items-center gap-2">
                            <i data-lucide="log-in"></i> ÂèÇÂä†„Åô„Çã („Ç≤„Çπ„Éà)
                        </h2>
                        <div className="flex gap-2">
                            <InputField 
                                value={targetId}
                                onChange={(e) => setTargetId(e.target.value.toUpperCase())}
                                placeholder="Áõ∏Êâã„ÅÆID„ÇíÂÖ•Âäõ"
                            />
                            <Button onClick={joinGame} disabled={!myId || !targetId}>ÂèÇÂä†</Button>
                        </div>
                    </div>
                </div>
            );

            const renderSetup = () => (
                <div className="max-w-md mx-auto space-y-6 animate-pop">
                    <div className="text-center">
                        <h2 className="text-2xl font-bold text-white">NG„ÉØ„Éº„ÉâË®≠ÂÆö</h2>
                        <p className="text-slate-400 text-sm">Áõ∏Êâã„Å´Ë®Ä„Çè„Åõ„Åü„ÅÑË®ÄËëâ„ÇíË®≠ÂÆö„Åó„Çà„ÅÜ</p>
                    </div>

                    <div className="space-y-4">
                        <div className="glass-panel p-4 rounded-xl border-l-4 border-red-500 relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-2 opacity-10">
                                <i data-lucide="skull" size={64}></i>
                            </div>
                            <label className="block text-red-400 font-bold mb-2">‚òÖ 3„Éù„Ç§„É≥„Éà (Âç≥Ê≠ª)</label>
                            <InputField 
                                value={ngWords[3]}
                                onChange={(e) => setNgWords({...ngWords, 3: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Åô„ÅÑ„Åã"
                            />
                        </div>
                        
                        <div className="glass-panel p-4 rounded-xl border-l-4 border-orange-500">
                            <label className="block text-orange-400 font-bold mb-2">‚òÖ 2„Éù„Ç§„É≥„Éà (Â§ß„ÉÄ„É°„Éº„Ç∏)</label>
                            <InputField 
                                value={ngWords[2]}
                                onChange={(e) => setNgWords({...ngWords, 2: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Çä„Çì„Åî (‰ªªÊÑè)"
                            />
                        </div>

                        <div className="glass-panel p-4 rounded-xl border-l-4 border-yellow-500">
                            <label className="block text-yellow-400 font-bold mb-2">‚òÖ 1„Éù„Ç§„É≥„Éà (Â∞è„ÉÄ„É°„Éº„Ç∏)</label>
                            <InputField 
                                value={ngWords[1]}
                                onChange={(e) => setNgWords({...ngWords, 1: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Åø„Åã„Çì (‰ªªÊÑè)"
                            />
                        </div>
                    </div>

                    <div className="text-center py-4">
                        {!iAmReady ? (
                            <Button onClick={handleReady} className="w-full text-lg shadow-cyan-500/20">
                                Ê∫ñÂÇôÂÆå‰∫ÜÔºÅ
                            </Button>
                        ) : (
                            <div className="text-cyan-400 animate-pulse font-bold text-lg">
                                Áõ∏Êâã„ÅÆÊ∫ñÂÇô„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...
                            </div>
                        )}
                    </div>
                </div>
            );

            const renderGame = () => {
                const isMyTurn = currentTurn === role;
                const gameOver = checkGameOver(myScore, oppScore);
                const winner = myScore >= 3 ? '„ÅÇ„Å™„Åü' : 'Áõ∏Êâã';

                if (gameOver) {
                    return (
                        <div className="max-w-md mx-auto text-center space-y-8 animate-pop py-10">
                            <div className="glass-panel p-8 rounded-3xl border-2 border-slate-500/50">
                                <h2 className="text-6xl mb-4">{myScore >= 3 ? 'üéâ' : 'üíÄ'}</h2>
                                <h2 className={`text-4xl font-black mb-2 ${myScore >= 3 ? 'text-yellow-400' : 'text-slate-400'}`}>
                                    {myScore >= 3 ? 'YOU WIN!' : 'YOU LOSE...'}
                                </h2>
                                <p className="text-slate-300">
                                    ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: {myScore} - {oppScore}
                                </p>
                            </div>
                            <Button onClick={() => resetGame(true)} variant="secondary">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÂØæÊà¶</Button>
                        </div>
                    );
                }

                return (
                    <div className="max-w-lg mx-auto h-screen flex flex-col p-2 gap-4">
                        {/* Status Bar */}
                        <div className="grid grid-cols-2 gap-4">
                            <div className="glass-panel p-3 rounded-xl">
                                <div className="text-xs text-slate-400 mb-1">YOU (Host/Guest)</div>
                                <HPBar points={myScore} isSelf={true} />
                                <div className="mt-2 text-xs text-right text-slate-500">Goal: 3pt</div>
                            </div>
                            <div className="glass-panel p-3 rounded-xl">
                                <div className="text-xs text-slate-400 mb-1 text-right">OPPONENT</div>
                                <HPBar points={oppScore} isSelf={false} />
                            </div>
                        </div>

                        {/* Game Area */}
                        <div className="flex-1 glass-panel rounded-2xl p-4 flex flex-col relative overflow-hidden">
                            {/* Timer */}
                            <div className={`absolute top-0 left-0 w-full h-1 bg-slate-700`}>
                                <div 
                                    className={`h-full transition-all duration-1000 ${timer < 5 ? 'bg-red-500' : 'bg-cyan-500'}`}
                                    style={{ width: `${(timer / 15) * 100}%` }}
                                ></div>
                            </div>

                            <div className="flex justify-between items-center mb-4 mt-2">
                                <div className="bg-slate-800 px-3 py-1 rounded-full text-sm text-slate-400">
                                    Ââç„ÅÆË®ÄËëâ: <span className="text-white font-bold text-lg ml-2">{lastChar}</span>
                                </div>
                                <div className={`font-mono text-2xl font-bold ${timer < 5 ? 'text-red-500 animate-pulse' : 'text-slate-300'}`}>
                                    {timer}s
                                </div>
                            </div>

                            {/* History */}
                            <div className="flex-1 overflow-y-auto space-y-2 mb-4 pr-2">
                                {history.map((h, i) => {
                                    const isMe = (h.player === 'host' && role === 'host') || (h.player === 'guest' && role === 'guest') || (h.player === 'me');
                                    // ‰øÆÊ≠£: „Éó„É¨„Ç§„É§„ÉºÂà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ„ÇíÁ∞°Á¥†Âåñ
                                    // history‰øùÂ≠òÊôÇ„Å´„Åô„Åß„Å´Ê≠£Ë¶èÂåñ„Åô„Çã„ÅÆ„Åå„Éô„Çπ„Éà„Å†„Åå„ÄÅË°®Á§∫ÊôÇ„Å´Ë£úÊ≠£
                                    // h.player„Åå 'me' „Åã„Å©„ÅÜ„Åã„ÅßÂà§ÂÆö
                                    // system„ÅÆÂ†¥Âêà„ÅØ‰∏≠Â§Æ
                                    if (h.player === 'system') {
                                        return (
                                            <div key={i} className="text-center text-slate-500 text-xs my-2">
                                                - {h.word} -
                                            </div>
                                        );
                                    }

                                    const isSelf = (currentTurn === role && i === 0) ? !isMe : isMe; // „Çø„Éº„É≥Â±•Ê≠¥„ÅÆË°®Á§∫„É≠„Ç∏„ÉÉ„ÇØ„ÅØÂ∞ë„ÅóË§áÈõë„Å™„ÅÆ„Åß„ÄÅÂçòÁ¥î„Å´‰øùÂ≠òÊôÇ„ÅÆisMe„Çí‰Ωø„ÅÜ

                                    return (
                                        <div key={i} className={`flex flex-col ${isMe ? 'items-end' : 'items-start'}`}>
                                            <div className={`px-4 py-2 rounded-2xl max-w-[80%] ${
                                                h.damage > 0 
                                                    ? 'bg-red-500/20 border border-red-500/50 text-red-200' 
                                                    : isMe ? 'bg-cyan-600/20 border border-cyan-500/30 text-cyan-100' : 'bg-slate-700/50 text-slate-300'
                                            }`}>
                                                <div className="text-lg font-bold">{h.word}</div>
                                                {h.damage > 0 && (
                                                    <div className="text-xs mt-1 border-t border-red-500/30 pt-1 text-red-400">
                                                        {h.reasons.join(', ')} (-{h.damage}pt)
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>

                            {/* Input Area */}
                            <div className="mt-auto space-y-2">
                                {statusMsg && <div className="text-center text-sm text-pink-400 h-5">{statusMsg}</div>}
                                <div className="flex gap-2">
                                    <InputField 
                                        value={inputWord}
                                        onChange={(e) => {
                                            setStatusMsg('');
                                            setInputWord(toHiragana(e.target.value));
                                        }}
                                        onKeyDown={(e) => e.key === 'Enter' && isMyTurn && handleSendWord()}
                                        placeholder={isMyTurn ? `„Äå${lastChar}„Äç„Åã„ÇâÂßã„Åæ„ÇãË®ÄËëâ` : "Áõ∏Êâã„ÅÆ„Çø„Éº„É≥„Åß„Åô..."}
                                        disabled={!isMyTurn}
                                        autoFocus
                                    />
                                    <Button 
                                        onClick={handleSendWord} 
                                        disabled={!isMyTurn || !inputWord}
                                        className={!isMyTurn ? "opacity-50 grayscale" : ""}
                                    >
                                        <i data-lucide="send"></i>
                                    </Button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="min-h-screen bg-slate-900 text-slate-200 selection:bg-cyan-500/30">
                    <div className="container mx-auto p-4 h-full">
                        {gameState === 'lobby' && renderLobby()}
                        {gameState === 'setup' && renderSetup()}
                        {(gameState === 'playing' || gameState === 'result') && renderGame()}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
