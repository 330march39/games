<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê¨°‰∏ñ‰ª£„Åó„Çä„Å®„Çä - NG Word Battle</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PeerJS (WebRTC Wrapper) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&display=swap');
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
        }
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .animate-pop {
            animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .hp-dot {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Utils ---
        const generateShortId = () => {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        };

        const toHiragana = (str) => {
            return str.replace(/[\u30a1-\u30f6]/g, match => {
                const chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        };

        const getLastChar = (word) => {
            if (!word) return '';
            const last = word.slice(-1);
            const map = {'„ÅÅ':'„ÅÇ','„ÅÉ':'„ÅÑ','„ÅÖ':'„ÅÜ','„Åá':'„Åà','„Åâ':'„Åä','„Å£':'„Å§','„ÇÉ':'„ÇÑ','„ÇÖ':'„ÇÜ','„Çá':'„Çà','„Çé':'„Çè'};
            if (map[last]) return map[last];
            if (last === '„Éº') {
                const prev = word.slice(-2, -1);
                if (map[prev]) return map[prev];
                return prev;
            }
            return last;
        };

        // --- Components ---

        const Loading = () => (
            <div className="flex justify-center items-center p-4">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-400"></div>
            </div>
        );

        const Button = ({ onClick, children, className = "", disabled = false, variant = "primary" }) => {
            const baseStyle = "px-6 py-3 rounded-xl font-bold transition-all transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg";
            const variants = {
                primary: "bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white",
                danger: "bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-400 hover:to-pink-500 text-white",
                secondary: "bg-slate-700 hover:bg-slate-600 text-slate-200 border border-slate-600"
            };
            return (
                <button 
                    onClick={onClick} 
                    disabled={disabled}
                    className={`${baseStyle} ${variants[variant]} ${className}`}
                >
                    {children}
                </button>
            );
        };

        const InputField = ({ value, onChange, placeholder, onKeyDown, autoFocus }) => (
            <input
                type="text"
                value={value}
                onChange={onChange}
                onKeyDown={onKeyDown}
                placeholder={placeholder}
                autoFocus={autoFocus}
                className="w-full bg-slate-800/50 border-2 border-slate-600 focus:border-cyan-400 text-white px-4 py-3 rounded-xl outline-none transition-colors text-lg font-mono tracking-widest"
            />
        );

        const HPBar = ({ points, max = 3, isSelf }) => (
            <div className={`flex gap-2 ${isSelf ? 'justify-end' : 'justify-start'}`}>
                {[...Array(max)].map((_, i) => (
                    <div 
                        key={i} 
                        className={`w-8 h-8 rounded-full border-2 border-slate-600 flex items-center justify-center hp-dot ${i < points ? 'bg-gradient-to-br from-yellow-400 to-orange-500 scale-100 shadow-[0_0_10px_rgba(250,204,21,0.6)]' : 'bg-slate-800 scale-90 opacity-40'}`}
                    >
                        {i < points && <i data-lucide="zap" className="w-4 h-4 text-white fill-current"></i>}
                    </div>
                ))}
            </div>
        );

        // --- Main App ---

        const App = () => {
            const [peer, setPeer] = useState(null);
            const [conn, setConn] = useState(null);
            const [myId, setMyId] = useState('');
            const [targetId, setTargetId] = useState('');
            
            const [gameState, setGameState] = useState('lobby');
            const [statusMsg, setStatusMsg] = useState('');
            
            const [isConnecting, setIsConnecting] = useState(false);
            const isConnectingRef = useRef(false);

            const [peerError, setPeerError] = useState(null);

            const [ngWords, setNgWords] = useState({ 3: '', 2: '', 1: '' });
            const [opponentReady, setOpponentReady] = useState(false);
            const [iAmReady, setIAmReady] = useState(false);

            const [history, setHistory] = useState([]);
            const [currentTurn, setCurrentTurn] = useState('host');
            const [role, setRole] = useState(null);
            const [myScore, setMyScore] = useState(0);
            const [oppScore, setOppScore] = useState(0);
            const [timer, setTimer] = useState(15);
            const [inputWord, setInputWord] = useState('');
            const [lastChar, setLastChar] = useState('');

            const timerRef = useRef(null);

            const setConnectingState = (state) => {
                setIsConnecting(state);
                isConnectingRef.current = state;
            };

            const initPeer = (retryCount = 0) => {
                if (retryCount > 3) {
                    setPeerError("ID„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                    return;
                }

                const shortId = generateShortId();
                const prefix = "NGW-"; 
                const fullId = prefix + shortId;

                setPeerError(null);
                
                const newPeer = new Peer(fullId, { 
                    debug: 1, // Debug level low to avoid spam
                    config: {'iceServers': [
                        { url: 'stun:stun.l.google.com:19302' },
                        { url: 'stun:stun1.l.google.com:19302' }
                    ]}
                }); 
                
                newPeer.on('open', (id) => {
                    setMyId(shortId); 
                    setPeer(newPeer);
                    setPeerError(null);
                });

                newPeer.on('connection', (connection) => {
                    setupConnection(connection, 'host');
                });

                newPeer.on('error', (err) => {
                    console.error("Peer Error Logged:", err);
                    setConnectingState(false);

                    if (err.type === 'unavailable-id') {
                        newPeer.destroy();
                        initPeer(retryCount + 1);
                        return;
                    }

                    // ‚òÖ CRITICAL FIX: Ignore non-fatal WebRTC state errors
                    // These happen frequently in P2P and usually don't mean the connection failed.
                    if (err.message && (
                        err.message.includes('stable') || 
                        err.message.includes('setRemoteDescription') ||
                        err.message.includes('InvalidStateError')
                    )) {
                        console.warn("Suppressed non-fatal PeerJS error:", err.message);
                        return; // Do NOT update UI error state
                    }

                    if (err.type === 'peer-unavailable') {
                        setStatusMsg(`„Ç®„É©„Éº: ID„Äå${targetId}„Äç„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ`);
                    } else if (err.type === 'network' || err.type === 'disconnected') {
                        setPeerError('„Çµ„Éº„Éê„Éº„Å®„ÅÆÊé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü„ÄÇ„É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    } else {
                        setPeerError(`ÈÄö‰ø°„Ç®„É©„Éº: ${err.type}`);
                    }
                });

                newPeer.on('disconnected', () => {
                     setPeerError('„Çµ„Éº„Éê„Éº„Åã„ÇâÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü');
                });

                return newPeer;
            };

            useEffect(() => {
                const p = initPeer();
                return () => {
                    if (p && p.destroy) p.destroy();
                };
            }, []);

            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            });

            // Timer Logic
            useEffect(() => {
                if (gameState === 'playing' && !checkGameOver(myScore, oppScore)) {
                    if (timerRef.current) clearInterval(timerRef.current);
                    setTimer(15);
                    timerRef.current = setInterval(() => {
                        setTimer((prev) => {
                            if (prev <= 1) {
                                clearInterval(timerRef.current);
                                handleTimeOut();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                }
                return () => clearInterval(timerRef.current);
            }, [currentTurn, gameState]);

            const copyToClipboard = (text) => {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    setStatusMsg('ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                    setTimeout(() => setStatusMsg(''), 2000);
                } catch (err) {
                    setStatusMsg('„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
                document.body.removeChild(textArea);
            };

            const setupConnection = (connection, myRole) => {
                if (conn && conn.open) {
                    console.log("Already connected, ignoring new connection attempt.");
                    return;
                }

                setConn(connection);
                setRole(myRole);
                
                connection.on('open', () => {
                    setConnectingState(false);
                    setGameState('setup');
                    setStatusMsg('Êé•Á∂öÂÆå‰∫ÜÔºÅ NG„ÉØ„Éº„Éâ„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    setPeerError(null);
                });

                connection.on('data', (data) => {
                    handleData(data);
                });
                
                connection.on('close', () => {
                    setPeerError('Áõ∏Êâã„Å®„ÅÆÊé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü„ÄÇÂØæÊà¶„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇ');
                    setConnectingState(false);
                });

                connection.on('error', (err) => {
                    console.error("Connection Error:", err);
                    setConnectingState(false);
                    // Connection errors are also often non-fatal race conditions in PeerJS
                });
            };

            const joinGame = () => {
                if (!peer || !targetId) return;

                if (isConnectingRef.current) {
                    console.log("Connection in progress, ignoring click.");
                    return;
                }

                const cleanId = targetId.trim().toUpperCase();
                const fullTargetId = "NGW-" + cleanId;

                if (conn) {
                    conn.close();
                    setConn(null);
                }

                if (peer.disconnected) {
                    peer.reconnect();
                }
                
                setConnectingState(true);
                setStatusMsg('Êé•Á∂ö‰∏≠...');

                setTimeout(() => {
                    try {
                        const connection = peer.connect(fullTargetId, {
                            serialization: 'json',
                            reliable: true
                        });
                        
                        if (!connection) {
                            setConnectingState(false);
                            setStatusMsg("Êé•Á∂ö„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
                            return;
                        }
                        
                        setupConnection(connection, 'guest');

                        setTimeout(() => {
                            if (!connection.open && isConnectingRef.current) {
                                setStatusMsg("Êé•Á∂ö„Å´ÊôÇÈñì„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Åæ„Åô...");
                                setTimeout(() => setConnectingState(false), 3000);
                            }
                        }, 5000);

                    } catch (e) {
                        console.error(e);
                        setConnectingState(false);
                        setStatusMsg("Êé•Á∂ö„Ç®„É©„Éº");
                    }
                }, 200);
            };

            const handleData = (data) => {
                switch (data.type) {
                    case 'READY':
                        setOpponentReady(true);
                        break;
                    case 'MOVE':
                        processReceivedWord(data.word);
                        break;
                    case 'RESULT':
                        applyResult(data);
                        break;
                    case 'RESTART':
                        resetGame(false);
                        break;
                }
            };

            const handleReady = () => {
                if (!ngWords[3]) {
                    setStatusMsg('ÊúÄ‰Ωé„Åß„ÇÇ„ÄåÂç≥Ê≠ªNG„ÉØ„Éº„Éâ(3pt)„Äç„ÅØË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ');
                    return;
                }
                setIAmReady(true);
                conn.send({ type: 'READY' });
            };

            useEffect(() => {
                if (iAmReady && opponentReady && gameState === 'setup') {
                    setGameState('playing');
                    setLastChar('„Çä'); 
                    setHistory([{ word: '„Åó„Çä„Å®„Çä', player: 'system', damage: 0 }]);
                    setCurrentTurn('host'); 
                    setStatusMsg('');
                }
            }, [iAmReady, opponentReady, gameState]);

            const processReceivedWord = (word) => {
                let damage = 0;
                let reasons = [];

                if (getLastChar(word) === '„Çì') {
                    damage += 3;
                    reasons.push('„Äå„Çì„Äç„Åå„Å§„ÅÑ„ÅüÔºÅ(Âç≥Ê≠ª)');
                }

                if (word === ngWords[3]) {
                    damage += 3;
                    reasons.push(`‚òÖ3pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                } else if (word === ngWords[2]) {
                    damage += 2;
                    reasons.push(`‚òÖ2pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                } else if (word === ngWords[1]) {
                    damage += 1;
                    reasons.push(`‚òÖ1pt NG„ÉØ„Éº„Éâ„Äå${word}„Äç„ÇíË∏è„Çì„Å†ÔºÅ`);
                }

                const isRepeated = history.some(h => h.word === word);
                if (isRepeated) {
                    damage += 1;
                    reasons.push('Êó¢Âá∫„ÉØ„Éº„ÉâÔºÅ');
                }

                const resultData = {
                    type: 'RESULT',
                    word: word,
                    player: 'opponent',
                    damage: damage,
                    reasons: reasons,
                    nextTurn: role === 'host' ? 'guest' : 'host'
                };

                conn.send(resultData);
                applyResult(resultData);
            };

            const handleSendWord = () => {
                const word = inputWord.trim();
                if (!word) return;
                
                const hira = toHiragana(word);
                
                if (!/^[\u3040-\u309f]+$/.test(hira)) {
                    setStatusMsg('„Å≤„Çâ„Åå„Å™„ÅÆ„ÅøÊúâÂäπ„Åß„Åô');
                    return;
                }
                if (lastChar && hira.charAt(0) !== lastChar) {
                    setStatusMsg(`„Äå${lastChar}„Äç„Åã„ÇâÂßã„Åæ„ÇãË®ÄËëâ„ÇíÂÖ•„Çå„Å¶„Åè„Å†„Åï„ÅÑ`);
                    return;
                }

                conn.send({ type: 'MOVE', word: hira });
                setInputWord('');
                setStatusMsg('Âà§ÂÆö‰∏≠...');
            };

            const handleTimeOut = () => {
                if (currentTurn === role) {
                    const resultData = {
                        type: 'RESULT',
                        word: '(ÊôÇÈñìÂàá„Çå)',
                        player: 'me',
                        damage: 1,
                        reasons: ['ÊôÇÈñìÂàá„ÇåÔºÅ'],
                        nextTurn: role === 'host' ? 'guest' : 'host'
                    };
                    conn.send(resultData);
                    applyResult(resultData);
                }
            };

            const applyResult = (data) => {
                setHistory(prev => [
                    { 
                        word: data.word, 
                        player: data.player === 'me' ? (role === data.player ? 'me' : 'opponent') : (role === data.player ? 'me' : 'opponent'),
                        isMe: (data.player === 'opponent' && role !== 'host') || (data.player === 'me' && role === 'host') ? false : true,
                        damage: data.damage,
                        reasons: data.reasons
                    }, 
                    ...prev
                ]);
                
                if (data.damage > 0) {
                     if (currentTurn === role) {
                         setOppScore(prev => Math.min(prev + data.damage, 3));
                     } else {
                         setMyScore(prev => Math.min(prev + data.damage, 3));
                     }
                }

                if (data.word !== '(ÊôÇÈñìÂàá„Çå)') {
                    setLastChar(getLastChar(data.word));
                }
                
                const newMyScore = currentTurn !== role ? myScore + data.damage : myScore;
                const newOppScore = currentTurn === role ? oppScore + data.damage : oppScore;
                
                if (newMyScore < 3 && newOppScore < 3) {
                     setCurrentTurn(data.nextTurn);
                }
            };

            const checkGameOver = (s1, s2) => {
                return s1 >= 3 || s2 >= 3;
            };

            const resetGame = (sendSignal = true) => {
                if (sendSignal && conn) conn.send({ type: 'RESTART' });
                setMyScore(0);
                setOppScore(0);
                setHistory([{ word: '„Åó„Çä„Å®„Çä', player: 'system', damage: 0 }]);
                setLastChar('„Çä');
                setCurrentTurn('host');
                setGameState('setup');
                setIAmReady(false);
                setOpponentReady(false);
                setNgWords({ 3: '', 2: '', 1: '' });
                setStatusMsg('');
            };

            const reloadPage = () => {
                window.location.reload();
            };

            const renderLobby = () => (
                <div className="max-w-md mx-auto space-y-8 animate-pop">
                    <div className="text-center space-y-2">
                        <h1 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                            NG WORD BATTLE
                        </h1>
                        <p className="text-slate-400">Ê¨°‰∏ñ‰ª£„Åó„Çä„Å®„Çä P2P</p>
                    </div>

                    {peerError && (
                        <div className="bg-red-500/20 border border-red-500 text-red-200 p-4 rounded-xl text-center mb-4">
                            <p className="mb-2"><i data-lucide="alert-triangle" className="inline mr-2"></i>{peerError}</p>
                            <Button onClick={reloadPage} variant="danger" className="text-sm py-2 px-4">ÂÜçË™≠„ÅøËæº„Åø</Button>
                        </div>
                    )}

                    <div className="glass-panel p-6 rounded-2xl space-y-4">
                        <h2 className="text-xl font-bold text-cyan-400 flex items-center gap-2">
                            <i data-lucide="user-plus"></i> ÈÉ®Â±ã„Çí‰Ωú„Çã („Éõ„Çπ„Éà)
                        </h2>
                        <div className="bg-slate-900/50 p-4 rounded-xl flex items-center justify-between border border-slate-700">
                            {myId ? (
                                <code className="text-3xl font-mono text-white tracking-widest font-bold text-center w-full">{myId}</code>
                            ) : (
                                <span className="text-slate-400 text-sm w-full text-center">IDÁîüÊàê‰∏≠...</span>
                            )}
                            <button 
                                onClick={() => copyToClipboard(myId)}
                                className="p-2 ml-2 hover:bg-slate-700 rounded-lg transition-colors text-slate-400 hover:text-white shrink-0"
                                title="ID„Çí„Ç≥„Éî„Éº"
                            >
                                <i data-lucide="copy"></i>
                            </button>
                        </div>
                        <p className="text-sm text-slate-500">„Åì„ÅÆ4ÊñáÂ≠ó„ÅÆID„ÇíÂèãÈÅî„Å´Êïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    </div>

                    <div className="glass-panel p-6 rounded-2xl space-y-4">
                        <h2 className="text-xl font-bold text-pink-400 flex items-center gap-2">
                            <i data-lucide="log-in"></i> ÂèÇÂä†„Åô„Çã („Ç≤„Çπ„Éà)
                        </h2>
                        <div className="flex gap-2">
                            <InputField 
                                value={targetId}
                                onChange={(e) => setTargetId(e.target.value.toUpperCase())}
                                placeholder="4ÊñáÂ≠ó„ÅÆID„ÇíÂÖ•Âäõ"
                            />
                            <Button onClick={joinGame} disabled={!myId || !targetId || isConnecting}>
                                {isConnecting ? <span className="animate-pulse">...</span> : 'ÂèÇÂä†'}
                            </Button>
                        </div>
                    </div>
                    {statusMsg && <div className="text-center text-cyan-400 font-bold bg-slate-800/50 p-2 rounded-lg">{statusMsg}</div>}
                </div>
            );

            const renderSetup = () => (
                <div className="max-w-md mx-auto space-y-6 animate-pop">
                    <div className="text-center">
                        <h2 className="text-2xl font-bold text-white">NG„ÉØ„Éº„ÉâË®≠ÂÆö</h2>
                        <p className="text-slate-400 text-sm">Áõ∏Êâã„Å´Ë®Ä„Çè„Åõ„Åü„ÅÑË®ÄËëâ„ÇíË®≠ÂÆö„Åó„Çà„ÅÜ</p>
                    </div>

                    <div className="space-y-4">
                        <div className="glass-panel p-4 rounded-xl border-l-4 border-red-500 relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-2 opacity-10">
                                <i data-lucide="skull" size={64}></i>
                            </div>
                            <label className="block text-red-400 font-bold mb-2">‚òÖ 3„Éù„Ç§„É≥„Éà (Âç≥Ê≠ª)</label>
                            <InputField 
                                value={ngWords[3]}
                                onChange={(e) => setNgWords({...ngWords, 3: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Åô„ÅÑ„Åã"
                            />
                        </div>
                        
                        <div className="glass-panel p-4 rounded-xl border-l-4 border-orange-500">
                            <label className="block text-orange-400 font-bold mb-2">‚òÖ 2„Éù„Ç§„É≥„Éà (Â§ß„ÉÄ„É°„Éº„Ç∏)</label>
                            <InputField 
                                value={ngWords[2]}
                                onChange={(e) => setNgWords({...ngWords, 2: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Çä„Çì„Åî (‰ªªÊÑè)"
                            />
                        </div>

                        <div className="glass-panel p-4 rounded-xl border-l-4 border-yellow-500">
                            <label className="block text-yellow-400 font-bold mb-2">‚òÖ 1„Éù„Ç§„É≥„Éà (Â∞è„ÉÄ„É°„Éº„Ç∏)</label>
                            <InputField 
                                value={ngWords[1]}
                                onChange={(e) => setNgWords({...ngWords, 1: toHiragana(e.target.value)})}
                                placeholder="‰æãÔºö„Åø„Åã„Çì (‰ªªÊÑè)"
                            />
                        </div>
                    </div>

                    {statusMsg && <div className="text-center text-pink-400 font-bold">{statusMsg}</div>}

                    <div className="text-center py-4">
                        {!iAmReady ? (
                            <Button onClick={handleReady} className="w-full text-lg shadow-cyan-500/20">
                                Ê∫ñÂÇôÂÆå‰∫ÜÔºÅ
                            </Button>
                        ) : (
                            <div className="text-cyan-400 animate-pulse font-bold text-lg">
                                Áõ∏Êâã„ÅÆÊ∫ñÂÇô„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...
                            </div>
                        )}
                    </div>
                </div>
            );

            const renderGame = () => {
                const isMyTurn = currentTurn === role;
                const gameOver = checkGameOver(myScore, oppScore);
                const winner = myScore >= 3 ? '„ÅÇ„Å™„Åü' : 'Áõ∏Êâã';

                if (gameOver) {
                    return (
                        <div className="max-w-md mx-auto text-center space-y-8 animate-pop py-10">
                            <div className="glass-panel p-8 rounded-3xl border-2 border-slate-500/50">
                                <h2 className="text-6xl mb-4">{myScore >= 3 ? 'üéâ' : 'üíÄ'}</h2>
                                <h2 className={`text-4xl font-black mb-2 ${myScore >= 3 ? 'text-yellow-400' : 'text-slate-400'}`}>
                                    {myScore >= 3 ? 'YOU WIN!' : 'YOU LOSE...'}
                                </h2>
                                <p className="text-slate-300">
                                    ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: {myScore} - {oppScore}
                                </p>
                            </div>
                            <Button onClick={() => resetGame(true)} variant="secondary">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÂØæÊà¶</Button>
                        </div>
                    );
                }

                return (
                    <div className="max-w-lg mx-auto h-screen flex flex-col p-2 gap-4">
                        {peerError && (
                            <div className="absolute inset-0 bg-slate-900/90 z-50 flex items-center justify-center p-6">
                                <div className="text-center space-y-4">
                                    <i data-lucide="wifi-off" className="mx-auto h-12 w-12 text-red-500"></i>
                                    <h3 className="text-xl font-bold text-white">Êé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü</h3>
                                    <p className="text-slate-400">{peerError}</p>
                                    <Button onClick={reloadPage} variant="danger">ÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶Âæ©Â∏∞</Button>
                                </div>
                            </div>
                        )}

                        <div className="grid grid-cols-2 gap-4">
                            <div className="glass-panel p-3 rounded-xl">
                                <div className="text-xs text-slate-400 mb-1">YOU (Host/Guest)</div>
                                <HPBar points={myScore} isSelf={true} />
                                <div className="mt-2 text-xs text-right text-slate-500">Goal: 3pt</div>
                            </div>
                            <div className="glass-panel p-3 rounded-xl">
                                <div className="text-xs text-slate-400 mb-1 text-right">OPPONENT</div>
                                <HPBar points={oppScore} isSelf={false} />
                            </div>
                        </div>

                        <div className="flex-1 glass-panel rounded-2xl p-4 flex flex-col relative overflow-hidden">
                            <div className={`absolute top-0 left-0 w-full h-1 bg-slate-700`}>
                                <div 
                                    className={`h-full transition-all duration-1000 ${timer < 5 ? 'bg-red-500' : 'bg-cyan-500'}`}
                                    style={{ width: `${(timer / 15) * 100}%` }}
                                ></div>
                            </div>

                            <div className="flex justify-between items-center mb-4 mt-2">
                                <div className="bg-slate-800 px-3 py-1 rounded-full text-sm text-slate-400">
                                    Ââç„ÅÆË®ÄËëâ: <span className="text-white font-bold text-lg ml-2">{lastChar}</span>
                                </div>
                                <div className={`font-mono text-2xl font-bold ${timer < 5 ? 'text-red-500 animate-pulse' : 'text-slate-300'}`}>
                                    {timer}s
                                </div>
                            </div>

                            <div className="flex-1 overflow-y-auto space-y-2 mb-4 pr-2">
                                {history.map((h, i) => {
                                    const isMe = (h.player === 'host' && role === 'host') || (h.player === 'guest' && role === 'guest') || (h.player === 'me');
                                    if (h.player === 'system') {
                                        return (
                                            <div key={i} className="text-center text-slate-500 text-xs my-2">
                                                - {h.word} -
                                            </div>
                                        );
                                    }

                                    const isSelf = (currentTurn === role && i === 0) ? !isMe : isMe;

                                    return (
                                        <div key={i} className={`flex flex-col ${isMe ? 'items-end' : 'items-start'}`}>
                                            <div className={`px-4 py-2 rounded-2xl max-w-[80%] ${
                                                h.damage > 0 
                                                    ? 'bg-red-500/20 border border-red-500/50 text-red-200' 
                                                    : isMe ? 'bg-cyan-600/20 border border-cyan-500/30 text-cyan-100' : 'bg-slate-700/50 text-slate-300'
                                            }`}>
                                                <div className="text-lg font-bold">{h.word}</div>
                                                {h.damage > 0 && (
                                                    <div className="text-xs mt-1 border-t border-red-500/30 pt-1 text-red-400">
                                                        {h.reasons.join(', ')} (-{h.damage}pt)
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>

                            <div className="mt-auto space-y-2">
                                {statusMsg && <div className="text-center text-sm text-pink-400 h-5">{statusMsg}</div>}
                                <div className="flex gap-2">
                                    <InputField 
                                        value={inputWord}
                                        onChange={(e) => {
                                            setStatusMsg('');
                                            setInputWord(toHiragana(e.target.value));
                                        }}
                                        onKeyDown={(e) => e.key === 'Enter' && isMyTurn && handleSendWord()}
                                        placeholder={isMyTurn ? `„Äå${lastChar}„Äç„Åã„ÇâÂßã„Åæ„ÇãË®ÄËëâ` : "Áõ∏Êâã„ÅÆ„Çø„Éº„É≥„Åß„Åô..."}
                                        disabled={!isMyTurn}
                                        autoFocus
                                    />
                                    <Button 
                                        onClick={handleSendWord} 
                                        disabled={!isMyTurn || !inputWord}
                                        className={!isMyTurn ? "opacity-50 grayscale" : ""}
                                    >
                                        <i data-lucide="send"></i>
                                    </Button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="min-h-screen bg-slate-900 text-slate-200 selection:bg-cyan-500/30">
                    <div className="container mx-auto p-4 h-full">
                        {gameState === 'lobby' && renderLobby()}
                        {gameState === 'setup' && renderSetup()}
                        {(gameState === 'playing' || gameState === 'result') && renderGame()}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
