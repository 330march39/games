<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WORD BATTLE: V7 SYNC FIX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Zen+Maru+Gothic:wght@500;700;900&display=swap');
        
        :root {
            --c-primary: #00f0ff;
            --c-secondary: #ff003c;
            --c-accent: #fcee0a;
            --bg-dark: #050505;
        }

        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: var(--bg-dark);
            color: #e0e0e0;
            overflow: hidden;
            touch-action: manipulation;
        }

        .app-container {
            position: fixed; inset: 0; width: 100vw; height: 100dvh;
            display: flex; flex-direction: column;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            overflow: hidden;
        }

        /* --- EFFECTS --- */
        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            position: absolute; inset: 0; pointer-events: none; z-index: 50; opacity: 0.6;
        }
        
        .crt-glow {
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            position: absolute; inset: 0; pointer-events: none; z-index: 51;
        }

        @keyframes glitch-skew {
            0% { transform: skew(0deg); }
            20% { transform: skew(-2deg); }
            40% { transform: skew(2deg); }
            60% { transform: skew(-1deg); }
            80% { transform: skew(1deg); }
            100% { transform: skew(0deg); }
        }
        .glitch-text {
            animation: glitch-skew 1s infinite linear alternate-reverse;
            text-shadow: 2px 0 var(--c-secondary), -2px 0 var(--c-primary);
        }

        .cyber-box {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid var(--c-primary);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.15);
            backdrop-filter: blur(4px);
            position: relative;
        }
        .cyber-box::before {
            content: ''; position: absolute; top: -1px; left: -1px; width: 10px; height: 10px;
            border-top: 2px solid var(--c-primary); border-left: 2px solid var(--c-primary);
        }
        .cyber-box::after {
            content: ''; position: absolute; bottom: -1px; right: -1px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--c-primary); border-right: 2px solid var(--c-primary);
        }

        .cyber-input {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            color: var(--c-primary);
            font-family: 'Zen Maru Gothic', sans-serif;
            transition: all 0.3s;
        }
        .cyber-input:focus {
            border-color: var(--c-primary);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
            outline: none;
        }

        /* --- VS ANIMATIONS --- */
        .vs-bg {
            background: repeating-linear-gradient(90deg, transparent 0, transparent 50px, rgba(0, 240, 255, 0.1) 50px, rgba(0, 240, 255, 0.1) 51px);
            animation: slide-bg 10s linear infinite;
        }
        @keyframes slide-bg { from { background-position: 0 0; } to { background-position: 100px 0; } }

        .slide-in-left { animation: slideInLeft 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards; }
        @keyframes slideInLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        .slide-in-right { animation: slideInRight 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards; }
        @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        .slam-in { animation: slamIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.8s forwards; opacity: 0; transform: scale(3); }
        @keyframes slamIn { to { opacity: 1; transform: scale(1); } }

        /* Coin & Shake */
        @keyframes flip { 0% { transform: rotateY(0); } 100% { transform: rotateY(1800deg); } }
        .coin-flip { animation: flip 3s ease-out forwards; transform-style: preserve-3d; }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        .shake-anim { animation: shake 0.4s; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border: 1px solid #555; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- CONSTANTS ---
        const SAMPLE_TOPICS = ["„Ç¢„Éã„É°„Ç≠„É£„É©", "Â≠¶Ê†°„Å´„ÅÇ„Çã„ÇÇ„ÅÆ", "„Ç≥„É≥„Éì„Éã„ÅÆÂïÜÂìÅ", "4ÊñáÂ≠ó„ÅÆË®ÄËëâ", "Á∑ëËâ≤„ÅÆ„ÇÇ„ÅÆ", "Ê≠¥Âè≤‰∏ä„ÅÆ‰∫∫Áâ©"];
        const MAX_HP = 5;
        const TIMER_SETUP = 60; // Topic selection & NG Input
        const TIMER_GAME = 60; // Per turn
        const DISCONNECT_TIMEOUT = 30000;
        const CONNECTION_WARNING_TIMEOUT = 3000;
        
        const HIRAGANA_CHARS = "„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù„Åü„Å°„Å§„Å¶„Å®„Å™„Å´„Å¨„Å≠„ÅÆ„ÅØ„Å≤„Åµ„Å∏„Åª„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„ÇÑ„ÇÜ„Çà„Çâ„Çä„Çã„Çå„Çç„Çè„Åå„Åé„Åê„Åí„Åî„Åñ„Åò„Åö„Åú„Åû„Å†„Å¢„Å•„Åß„Å©„Å∞„Å≥„Å∂„Åπ„Åº„Å±„Å¥„Å∑„Å∫„ÅΩ";
        const getRandomChar = () => HIRAGANA_CHARS[Math.floor(Math.random() * HIRAGANA_CHARS.length)];

        // --- UTILS ---
        const generateId = () => Math.random().toString(36).substring(2, 6).toUpperCase();
        const toHiragana = (str) => str.replace(/[\u30a1-\u30f6]/g, m => String.fromCharCode(m.charCodeAt(0) - 0x60));
        const getLastChar = (w) => {
            if(!w) return '';
            const last = w.slice(-1);
            const map = {'„ÅÅ':'„ÅÇ','„ÅÉ':'„ÅÑ','„ÅÖ':'„ÅÜ','„Åá':'„Åà','„Åâ':'„Åä','„Å£':'„Å§','„ÇÉ':'„ÇÑ','„ÇÖ':'„ÇÜ','„Çá':'„Çà','„Çé':'„Çè'};
            if(map[last]) return map[last];
            if(last === '„Éº') {
                const prev = w.slice(-2, -1);
                return map[prev] || prev;
            }
            return last;
        };

        // --- COMPONENTS ---
        const Button = ({ onClick, children, className="", disabled=false, variant="primary", icon }) => {
            const base = "relative overflow-hidden font-bold uppercase tracking-wider transition-all active:scale-95 disabled:opacity-50 disabled:active:scale-100 flex items-center justify-center gap-2 px-6 py-3 clip-path-polygon whitespace-nowrap";
            const styles = {
                primary: "bg-cyan-600 text-white hover:bg-cyan-500 shadow-[0_0_20px_rgba(6,182,212,0.4)]",
                danger: "bg-rose-600 text-white hover:bg-rose-500 shadow-[0_0_20px_rgba(225,29,72,0.4)]",
                ghost: "bg-transparent border border-cyan-500/50 text-cyan-400 hover:bg-cyan-950/30"
            };
            return (
                <button onClick={onClick} disabled={disabled} className={`${base} ${styles[variant]} ${className}`} style={{clipPath: 'polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%)'}}>
                    {icon && <i data-lucide={icon} className="w-5 h-5"></i>}
                    {children}
                </button>
            );
        };

        const CyberInput = ({ value, onChange, placeholder, label, color="cyan", maxLength, type="text" }) => (
            <div className="w-full relative group">
                {label && <div className={`text-[10px] font-bold mb-1 tracking-widest ${color==='rose'?'text-rose-400':'text-cyan-400'}`}>{label}</div>}
                <input type={type} value={value} onChange={onChange} placeholder={placeholder} maxLength={maxLength}
                    className={`cyber-input w-full px-4 py-3 text-lg font-bold ${color==='rose'?'text-rose-400 border-rose-900 focus:border-rose-500':'text-cyan-400'}`} />
                <div className={`absolute bottom-0 right-0 w-2 h-2 ${color==='rose'?'bg-rose-500':'bg-cyan-500'} opacity-50 group-focus-within:opacity-100`}></div>
            </div>
        );

        // --- MAIN APP ---
        const App = () => {
            // Net
            const [peer, setPeer] = useState(null);
            const [conn, setConn] = useState(null);
            const [myId, setMyId] = useState('');
            const [targetId, setTargetId] = useState('');
            const [isHost, setIsHost] = useState(false);
            
            // User Data
            const [userName, setUserName] = useState('');
            const [oppName, setOppName] = useState('RIVAL');

            // Flow
            const [phase, setPhase] = useState('lobby'); 
            const [error, setError] = useState('');
            const [damageAlert, setDamageAlert] = useState(null);

            // Connection Health
            const [lastActiveTime, setLastActiveTime] = useState(Date.now());
            const [isUnstable, setIsUnstable] = useState(false);

            // Data
            const [myTopic, setMyTopic] = useState('');
            const [oppTopic, setOppTopic] = useState('');
            const [isMyTopicConfirmed, setIsMyTopicConfirmed] = useState(false);
            const [isOppTopicConfirmed, setIsOppTopicConfirmed] = useState(false);
            
            const [rouletteData, setRouletteData] = useState({ candidates: [], winner: null });
            const [rouletteDisplay, setRouletteDisplay] = useState('');
            const [selectedTopic, setSelectedTopic] = useState(null);
            const [ngWords, setNgWords] = useState({ high: '', mid: '', low: '' });
            const [oppNgReady, setOppNgReady] = useState(false);
            const [coinResult, setCoinResult] = useState(null);
            
            // Game State
            const [history, setHistory] = useState([]);
            const [turn, setTurn] = useState('host');
            const [myHp, setMyHp] = useState(MAX_HP);
            const [oppHp, setOppHp] = useState(MAX_HP);
            const [input, setInput] = useState('');
            const [lastChar, setLastChar] = useState('');
            
            // Timer Logic
            const [displayTimer, setDisplayTimer] = useState(0); 
            const [phaseStartTime, setPhaseStartTime] = useState(0); // Absolute time when phase started
            const [turnStartTime, setTurnStartTime] = useState(0); // For playing phase
            
            const stateRef = useRef({ 
                phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName,
                turnStartTime, phaseStartTime, lastActiveTime, isMyTopicConfirmed, isOppTopicConfirmed
            });
            const connRef = useRef(null); 
            const scrollRef = useRef(null);
            const loopRef = useRef(null);

            // Sync References
            useEffect(() => {
                stateRef.current = { 
                    phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName,
                    turnStartTime, phaseStartTime, lastActiveTime, isMyTopicConfirmed, isOppTopicConfirmed
                };
            }, [phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName, turnStartTime, phaseStartTime, lastActiveTime, isMyTopicConfirmed, isOppTopicConfirmed]);

            // Load/Save Name
            useEffect(() => { const saved = localStorage.getItem('nwb_username'); if(saved) setUserName(saved); }, []);
            useEffect(() => { if(userName) localStorage.setItem('nwb_username', userName); }, [userName]);

            // Init Peer
            useEffect(() => {
                const id = generateId();
                const p = new Peer(`NWB-${id}`);
                p.on('open', () => { setMyId(id); setPeer(p); });
                p.on('connection', c => setupConn(c, true));
                p.on('error', e => showError('ID„Ç®„É©„Éº: „É™„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'));
                return () => p.destroy();
            }, []);

            useEffect(() => { if(window.lucide) window.lucide.createIcons(); });
            useEffect(() => { if(scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight; }, [history]);

            // Heartbeat
            useEffect(() => {
                const handleVisibilityChange = () => { if (document.visibilityState === 'visible') send({ type: 'REQUEST_SYNC' }); };
                document.addEventListener('visibilitychange', handleVisibilityChange);

                const heartbeat = setInterval(() => {
                    const now = Date.now();
                    if(stateRef.current.phase !== 'lobby') send({ type: 'PING', ts: now });

                    if(stateRef.current.phase !== 'lobby') {
                        const elapsed = now - stateRef.current.lastActiveTime;
                        if (elapsed > CONNECTION_WARNING_TIMEOUT && !isUnstable) setIsUnstable(true);
                        else if (elapsed <= CONNECTION_WARNING_TIMEOUT && isUnstable) setIsUnstable(false);
                        
                        if (stateRef.current.phase === 'playing' && elapsed > DISCONNECT_TIMEOUT) {
                            applyDamage('opp', 999, 'ÈÄö‰ø°ÈÄîÁµ∂ (VICTORY)');
                            clearInterval(heartbeat);
                        }
                    }
                }, 1000);
                return () => { document.removeEventListener('visibilitychange', handleVisibilityChange); clearInterval(heartbeat); };
            }, [isUnstable]);

            // Unified Timer Loop (Absolute Time)
            useEffect(() => {
                const loop = () => {
                    const s = stateRef.current;
                    const now = Date.now();
                    let targetTime = 0;
                    let duration = 0;

                    if (s.phase === 'topic_input') {
                        targetTime = s.phaseStartTime;
                        duration = TIMER_SETUP;
                    } else if (s.phase === 'ng_input') {
                        targetTime = s.phaseStartTime;
                        duration = TIMER_SETUP;
                    } else if (s.phase === 'playing' && s.turnStartTime > 0) {
                        targetTime = s.turnStartTime;
                        duration = TIMER_GAME;
                    }

                    if (targetTime > 0) {
                        const elapsedSec = (now - targetTime) / 1000;
                        const remain = Math.max(0, Math.ceil(duration - elapsedSec));
                        setDisplayTimer(remain);

                        // Host enforces timeout
                        if (s.isHost && remain <= 0) {
                            if (s.phase === 'playing') handleTimeout();
                            else if (s.phase === 'ng_input') forceStartGame(); // Force start if NG setup times out
                            // topic_input timeout is less critical, usually allow wait
                        }
                    }
                    loopRef.current = requestAnimationFrame(loop);
                };
                loopRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(loopRef.current);
            }, []);

            // --- NETWORKING ---
            const connect = () => { if(!targetId || !peer) return; setupConn(peer.connect(`NWB-${targetId.toUpperCase()}`), false); };

            const setupConn = (c, amHost) => {
                setConn(c); connRef.current = c; setIsHost(amHost);
                c.on('open', () => {
                    send({ type: 'NAME_SYNC', name: stateRef.current.userName || 'PLAYER' });
                    setLastActiveTime(Date.now());
                    setPhase('vs');
                    setTimeout(() => {
                        startPhase('topic_input');
                    }, 4000);
                });
                c.on('data', handleData);
                c.on('close', () => { showError('ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü'); resetGame(); });
            };

            const send = (data) => { if(connRef.current?.open) connRef.current.send(data); };

            const startPhase = (newPhase) => {
                const now = Date.now();
                setPhase(newPhase);
                setPhaseStartTime(now);
                if (stateRef.current.isHost) {
                    send({ type: 'PHASE_CHANGE', phase: newPhase, startTime: now });
                }
            };

            const handleData = (data) => {
                const s = stateRef.current;
                setLastActiveTime(Date.now());

                switch(data.type) {
                    case 'PING': break;
                    case 'REQUEST_SYNC':
                        send({ 
                            type: 'SYNC_FULL', 
                            myHp: s.myHp, oppHp: s.oppHp, turn: s.turn, 
                            turnStartTime: s.turnStartTime, history: s.history, lastChar: s.lastChar
                        });
                        break;
                    case 'SYNC_FULL':
                        setOppHp(prev => Math.min(prev, data.myHp));
                        setMyHp(prev => Math.min(prev, data.oppHp));
                        setTurn(data.turn);
                        setTurnStartTime(data.turnStartTime);
                        if(data.history.length > s.history.length) setHistory(data.history);
                        setLastChar(data.lastChar);
                        break;
                    case 'NAME_SYNC':
                        setOppName(data.name || 'RIVAL');
                        if(s.isHost) send({ type: 'NAME_SYNC', name: s.userName || 'PLAYER' });
                        break;
                    case 'PHASE_CHANGE':
                        setPhase(data.phase);
                        setPhaseStartTime(data.startTime);
                        break;

                    // TOPIC PHASE
                    case 'TOPIC_CONFIRM':
                        setOppTopic(data.topic);
                        setIsOppTopicConfirmed(true);
                        // If I am host and both confirmed, start
                        if (s.isHost && s.isMyTopicConfirmed) {
                             startRoulette(s.myTopic, data.topic);
                        }
                        break;
                    case 'ROULETTE_START':
                        setOppTopic(data.hostTopic); playRouletteAnimation(data.candidates, data.winner);
                        break;
                        
                    // NG PHASE
                    case 'NG_READY':
                        setOppNgReady(true); if(s.isHost && s.phase === 'ng_wait') startCoinToss();
                        break;
                    case 'FORCE_NG_COMPLETE':
                        // Host forced completion (timeout)
                        setOppNgReady(true); // Treat as ready
                        if(s.isHost) startCoinToss(); // Host proceeds
                        break;

                    case 'COIN_TOSS_START':
                        setCoinResult(data.result); setLastChar(data.initialChar); setPhase('coin');
                        setTimeout(() => {
                            setPhase('playing'); setTurn(data.result); setHistory([]);
                        }, 4000);
                        break;
                    case 'START_GAME':
                        setPhase('playing'); setTurnStartTime(data.startTime);
                        break;
                    case 'MOVE': 
                        receiveMove(data.word); 
                        break;
                    case 'TURN_CHANGE':
                        setTurn(data.nextTurn); setTurnStartTime(data.startTime);
                        setMyHp(prev => Math.min(prev, data.oppHp)); 
                        setOppHp(prev => Math.min(prev, data.myHp));
                        break;
                    case 'DAMAGE_REPORT':
                        applyDamage('me', data.amount, data.reason);
                        if(data.remainingHp !== undefined) setMyHp(prev => Math.min(prev, data.remainingHp));
                        break;
                    case 'REMATCH': resetGame(); break;
                }
            };

            // --- GAME LOGIC ---
            const submitTopic = () => {
                if(!myTopic) return showError("„ÅäÈ°å„ÇíÂÖ•Âäõ„Åõ„Çà");
                setIsMyTopicConfirmed(true);
                send({ type: 'TOPIC_CONFIRM', topic: myTopic });
                
                // If I am host and I already have opponent's topic
                const s = stateRef.current;
                if (isHost && s.isOppTopicConfirmed) {
                    startRoulette(myTopic, s.oppTopic);
                }
            };

            const startRoulette = (hostT, guestT) => {
                const isHostChosen = Math.random() > 0.5;
                const winner = isHostChosen ? { text: hostT, owner: 'host' } : { text: guestT, owner: 'guest' };
                const candidates = [hostT, guestT];
                playRouletteAnimation(candidates, winner);
                send({ type: 'ROULETTE_START', candidates, winner, hostTopic: hostT });
            };

            const playRouletteAnimation = (candidates, winner) => {
                setPhase('roulette'); setRouletteData({ candidates, winner });
                let count = 0;
                const spin = () => {
                    setRouletteDisplay(candidates[count % 2]); count++;
                    if(count < 20) setTimeout(spin, 50 + count * 10);
                    else {
                        setRouletteDisplay(winner.text); setSelectedTopic(winner);
                        setTimeout(() => { 
                            startPhase('ng_input');
                        }, 2000);
                    }
                };
                spin();
            };

            const submitNg = () => {
                if(!ngWords.high) return showError("3pt NG„ÉØ„Éº„Éâ„ÅØÂøÖÈ†à„Å†");
                setPhase('ng_wait'); send({ type: 'NG_READY' });
                if(isHost && oppNgReady) startCoinToss();
            };

            // Force start if timeout in NG phase
            const forceStartGame = () => {
                const s = stateRef.current;
                // If I haven't submitted NG, fill with garbage
                if (s.phase === 'ng_input') {
                    if (!ngWords.high) setNgWords({high:'„ÅÇ', mid:'„ÅÑ', low:'„ÅÜ'}); // Fallback
                    setPhase('ng_wait');
                    // Treat everyone as ready
                    send({ type: 'FORCE_NG_COMPLETE' }); 
                    startCoinToss();
                }
            };

            const startCoinToss = () => {
                const initialChar = getRandomChar();
                const firstPlayer = Math.random() > 0.5 ? 'host' : 'guest';
                send({ type: 'COIN_TOSS_START', result: firstPlayer, initialChar });
                setCoinResult(firstPlayer); setLastChar(initialChar); setPhase('coin');
                setTimeout(() => {
                    setPhase('playing'); setTurn(firstPlayer); setHistory([]); setTurnStartTime(Date.now());
                    send({ type: 'START_GAME', startTime: Date.now(), initialChar }); 
                }, 4000);
            };

            const handleTimeout = () => {
                const s = stateRef.current;
                const damage = 1;
                if (s.turn === 'host') applyDamage('me', damage, 'ÊôÇÈñìÂàá„Çå');
                else {
                    applyDamage('opp', damage, 'ÊôÇÈñìÂàá„Çå');
                    send({ type: 'DAMAGE_REPORT', amount: damage, reason: 'ÊôÇÈñìÂàá„Çå', remainingHp: Math.max(0, s.oppHp - damage) });
                }
                changeTurnInternal(s.turn === 'host' ? 'guest' : 'host');
            };

            const submitWord = () => {
                if(!input) return;
                const hira = toHiragana(input);
                if (!/^[\u3040-\u309f„Éº]+$/.test(hira)) return showError('„Å≤„Çâ„Åå„Å™„ÅÆ„ÅøÊúâÂäπ');
                if (lastChar && hira[0] !== lastChar) return showError(`„Äå${lastChar}„Äç„Åã„ÇâÈñãÂßã„Åõ„Çà`);
                if (history.some(h => h.word === hira)) return showError('Êó¢Âá∫„ÉØ„Éº„Éâ');
                
                const newHistory = [...history, { word: hira, owner: isHost?'host':'guest', damage: 0 }];
                setHistory(newHistory);
                setInput('');

                if(hira.slice(-1) === '„Çì') {
                    const suicideHist = [...history, { word: hira, owner: isHost?'host':'guest', damage: MAX_HP }];
                    setHistory(suicideHist);
                    applyDamage('me', MAX_HP, 'Ëá™ÁàÜ:„Äå„Çì„Äç');
                    send({ type: 'MOVE', word: hira });
                    send({ type: 'SYNC_FULL', myHp: 0, oppHp: oppHp, turn: turn, history: suicideHist, turnStartTime: Date.now(), lastChar: getLastChar(hira) });
                    return;
                }

                send({ type: 'MOVE', word: hira });
                setLastChar(getLastChar(hira));
                changeTurnInternal(isHost?'guest':'host');
            };

            const receiveMove = (word) => {
                const s = stateRef.current;
                let dmg = 0;
                let reason = '';
                
                if(word === s.ngWords.high) { dmg = 3; reason = 'NG„ÉØ„Éº„Éâ(3pt)Ë∏èÁ†¥!'; }
                else if(word === s.ngWords.mid) { dmg = 2; reason = 'NG„ÉØ„Éº„Éâ(2pt)Ë∏èÁ†¥!'; }
                else if(word === s.ngWords.low) { dmg = 1; reason = 'NG„ÉØ„Éº„Éâ(1pt)Ë∏èÁ†¥!'; }
                if(word.slice(-1) === '„Çì') { dmg = MAX_HP; reason = 'Ëá™ÁàÜ:„Äå„Çì„Äç'; }

                const owner = !s.isHost ? 'host' : 'guest';
                const newHistory = [...s.history, { word, owner, damage: dmg }];
                setHistory(newHistory);
                setLastChar(getLastChar(word));

                if(dmg > 0) {
                    applyDamage('opp', dmg, reason);
                    const newOppHp = Math.max(0, s.oppHp - dmg);
                    send({ type: 'DAMAGE_REPORT', amount: dmg, reason, remainingHp: newOppHp });
                }

                if (s.isHost) changeTurnInternal(s.isHost ? 'host' : 'guest');
                else setTurn(s.isHost ? 'host' : 'guest');
            };

            const changeTurnInternal = (next) => {
                const now = Date.now();
                setTurn(next); setTurnStartTime(now);
                if (stateRef.current.isHost) {
                    send({ type: 'TURN_CHANGE', nextTurn: next, startTime: now, myHp: stateRef.current.myHp, oppHp: stateRef.current.oppHp });
                }
            };

            const applyDamage = (target, amount, msg) => {
                setDamageAlert({ target, amount, reason: msg });
                setTimeout(() => setDamageAlert(null), 2000);
                let setHp = target === 'me' ? setMyHp : setOppHp;
                let currentHp = target === 'me' ? stateRef.current.myHp : stateRef.current.oppHp;
                const nextHp = Math.max(0, currentHp - amount);
                setHp(nextHp);
                setHistory(prev => {
                    if(prev.length === 0) return prev;
                    if(msg.includes('NG') || msg.includes('Ëá™ÁàÜ')) {
                        const last = prev[prev.length - 1];
                        if(last.damage === 0) {
                            const updated = [...prev];
                            updated[updated.length-1] = { ...last, damage: amount };
                            return updated;
                        }
                    }
                    return prev;
                });
                if(nextHp <= 0) setTimeout(() => setPhase('result'), 2500);
            };

            const showError = (msg) => { setError(msg); setTimeout(() => setError(''), 3000); };
            const handleRematch = () => { send({ type: 'REMATCH' }); resetGame(); };
            const resetGame = () => {
                setPhase('lobby'); setMyTopic(''); setOppTopic(''); setSelectedTopic(null);
                setNgWords({ high:'', mid:'', low:'' }); setOppNgReady(false);
                setIsMyTopicConfirmed(false); setIsOppTopicConfirmed(false);
                setHistory([]); setMyHp(MAX_HP); setOppHp(MAX_HP); setDamageAlert(null);
                setTurnStartTime(0); setPhaseStartTime(0); setIsUnstable(false);
            };
            const copyId = () => {
                 const t = document.createElement("textarea"); t.value = myId;
                 t.style.position="fixed"; t.style.left="-9999px"; document.body.appendChild(t);
                 t.focus(); t.select(); document.execCommand('copy'); document.body.removeChild(t);
                 showError('ID COPIED');
            };

            const isMyTurn = turn === (isHost?'host':'guest');

            // --- RENDER ---
            return (
                <div className="app-container font-sans text-white">
                    <div className="scanlines"></div>
                    <div className="crt-glow"></div>

                    {error && <div className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-[100] w-full max-w-sm px-4 flex justify-center"><div className="bg-rose-600 px-6 py-4 rounded shadow-[0_0_20px_#e11d48] font-bold border border-white animate-bounce text-center text-lg">{error}</div></div>}

                    {isUnstable && phase !== 'lobby' && phase !== 'result' && (
                        <div className="fixed inset-0 z-[999] pointer-events-none flex items-center justify-center bg-black/50 backdrop-blur-sm">
                            <div className="bg-rose-600 text-white px-8 py-4 text-2xl font-black border-4 border-white animate-pulse shadow-[0_0_50px_#e11d48]">
                                ‚ö†Ô∏è SIGNAL LOST - RECONNECTING...
                            </div>
                        </div>
                    )}

                    {damageAlert && (
                        <div className="fixed inset-0 z-[90] flex items-center justify-center pointer-events-none">
                            <div className="absolute inset-0 bg-rose-900/40 animate-pulse"></div>
                            <div className="relative z-10 text-center shake-anim">
                                <div className="text-8xl font-black text-rose-500 drop-shadow-[0_0_10px_rgba(255,0,0,0.8)]" style={{fontFamily: 'Black Ops One'}}>-{damageAlert.amount}</div>
                                <div className="text-2xl font-bold text-white bg-black/80 px-4 py-2 mt-2 border border-rose-500">{damageAlert.reason}</div>
                            </div>
                        </div>
                    )}

                    {/* LOBBY */}
                    {phase === 'lobby' && (
                        <div className="flex flex-col items-center justify-center h-full p-8 z-10 space-y-8 overflow-y-auto">
                            <div className="text-center relative">
                                <h1 className="text-6xl md:text-8xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-t from-cyan-600 to-white glitch-text" style={{fontFamily: 'Black Ops One'}}>STRATEGY</h1>
                                <p className="text-cyan-500 tracking-[1em] text-xs mt-2 font-bold">NEON WORD BATTLE</p>
                            </div>
                            <div className="w-full max-w-sm space-y-6">
                                <div className="cyber-box p-6">
                                    <div className="text-cyan-400 text-xs font-bold mb-4 tracking-widest border-b border-cyan-900 pb-2">PLAYER SETUP</div>
                                    <CyberInput value={userName} onChange={(e) => setUserName(e.target.value)} placeholder="ENTER NAME" label="CODENAME (MAX 8)" maxLength={8}/>
                                </div>
                                <div className="cyber-box p-6">
                                    <div className="text-cyan-400 text-xs font-bold mb-2 tracking-widest">HOST UNIT</div>
                                    <div className="flex gap-2">
                                        <div className="flex-1 bg-black/50 border border-cyan-900/50 flex items-center justify-center text-2xl font-mono text-cyan-200 h-14">{myId || 'INIT...'}</div>
                                        <Button onClick={copyId} variant="ghost" icon="copy" />
                                    </div>
                                </div>
                                <div className="cyber-box p-6 !border-rose-500/50">
                                    <div className="text-rose-400 text-xs font-bold mb-2 tracking-widest">JOIN TARGET</div>
                                    <div className="flex flex-wrap gap-2">
                                        <input value={targetId} onChange={e => setTargetId(e.target.value.toUpperCase())} placeholder="TARGET ID" className="flex-1 min-w-[140px] bg-black/50 border border-rose-900/50 text-rose-200 px-4 py-3 text-center text-xl font-mono outline-none focus:border-rose-500"/>
                                        <Button onClick={connect} variant="danger" className="flex-1 min-w-[80px]">JOIN</Button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* VS SCREEN */}
                    {phase === 'vs' && (
                        <div className="fixed inset-0 z-50 bg-black flex flex-col items-center justify-center overflow-hidden">
                            <div className="absolute inset-0 vs-bg opacity-30"></div>
                            <div className="relative w-full h-full flex items-center justify-center">
                                <div className="absolute left-0 top-1/4 w-1/2 h-48 bg-cyan-900/30 border-r-4 border-cyan-500 transform skew-x-12 -ml-10 flex items-center justify-end pr-10 slide-in-left">
                                    <div className="text-right transform -skew-x-12"><div className="text-cyan-300 text-sm tracking-[0.5em] mb-2">CHALLENGER</div><div className="text-5xl font-black text-white">{userName || 'YOU'}</div></div>
                                </div>
                                <div className="absolute right-0 bottom-1/4 w-1/2 h-48 bg-rose-900/30 border-l-4 border-rose-500 transform skew-x-12 -mr-10 flex items-center justify-start pl-10 slide-in-right">
                                    <div className="text-left transform -skew-x-12"><div className="text-rose-300 text-sm tracking-[0.5em] mb-2">OPPONENT</div><div className="text-5xl font-black text-white">{oppName || 'RIVAL'}</div></div>
                                </div>
                                <div className="z-10 text-9xl font-black italic text-transparent bg-clip-text bg-gradient-to-t from-white to-slate-400 drop-shadow-[0_0_25px_rgba(255,255,255,0.8)] slam-in" style={{fontFamily: 'Black Ops One'}}>VS</div>
                            </div>
                            <div className="absolute bottom-10 text-xs tracking-[1em] text-slate-500 animate-pulse">NEURAL LINK ESTABLISHED</div>
                        </div>
                    )}

                    {/* ROULETTE */}
                    {phase === 'roulette' && (
                        <div className="fixed inset-0 z-50 bg-black flex flex-col items-center justify-center space-y-8">
                            <div className="text-cyan-500 text-sm tracking-[0.5em] animate-pulse">DECIDING TOPIC...</div>
                            <div className="text-5xl md:text-7xl font-black text-white p-4 border-y-4 border-cyan-500 w-full text-center bg-cyan-900/20 roulette-anim glitch-text">{rouletteDisplay}</div>
                        </div>
                    )}

                    {/* COIN TOSS */}
                    {phase === 'coin' && (
                        <div className="fixed inset-0 z-50 bg-black/90 flex flex-col items-center justify-center">
                            <div className="text-xs tracking-[0.5em] text-cyan-400 mb-8">DECIDING FIRST ATTACKER</div>
                            <div className="w-48 h-48 coin-flip relative">
                                <div className="absolute inset-0 rounded-full border-4 border-cyan-500 bg-cyan-900/50 flex items-center justify-center text-4xl font-black text-cyan-200" style={{backfaceVisibility: 'hidden'}}>
                                    {coinResult === (isHost?'host':'guest') ? 'YOU' : 'RIVAL'}
                                </div>
                                <div className="absolute inset-0 rounded-full border-4 border-rose-500 bg-rose-900/50 flex items-center justify-center text-4xl font-black text-rose-200" style={{backfaceVisibility: 'hidden', transform: 'rotateY(180deg)'}}>
                                    {coinResult === (isHost?'host':'guest') ? 'YOU' : 'RIVAL'}
                                </div>
                            </div>
                            <div className="mt-12 text-2xl font-bold animate-bounce">
                                {coinResult === (isHost?'host':'guest') ? 'YOU GO FIRST!' : 'RIVAL GOES FIRST!'}
                            </div>
                        </div>
                    )}

                    {/* TOPIC INPUT */}
                    {(phase === 'topic_input' || phase === 'topic_wait') && (
                        <div className="flex flex-col h-full z-10 p-6 items-center justify-center space-y-8 bg-black/80">
                            {(isMyTopicConfirmed && !isHost) || (isHost && isMyTopicConfirmed && !isOppTopicConfirmed) ? (
                                <div className="text-center animate-pulse"><div className="text-2xl font-black text-cyan-400 mb-2">WAITING FOR RIVAL</div><div className="text-xs text-slate-500">„ÅäÈ°åÊ±∫ÂÆöÂæÖ„Å°...</div></div>
                            ) : (
                                <div className="w-full max-w-md space-y-6 animate-enter">
                                    <div className="flex justify-between items-end border-b border-cyan-900 pb-2"><h2 className="text-2xl font-black text-white">TOPIC PHASE</h2><div className="text-xl font-mono text-cyan-400">{displayTimer}s</div></div>
                                    <div className="space-y-4">
                                        <CyberInput value={myTopic} onChange={e => setMyTopic(e.target.value)} placeholder="‰æãÔºöËµ§„ÅÑ„ÇÇ„ÅÆ" label="PROPOSED TOPIC"/>
                                        <div className="flex gap-3"><Button onClick={() => setMyTopic(SAMPLE_TOPICS[Math.floor(Math.random()*SAMPLE_TOPICS.length)])} variant="ghost" className="flex-1 text-xs">RANDOM</Button><Button onClick={submitTopic} className="flex-[2]">CONFIRM</Button></div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* NG INPUT */}
                    {(phase === 'ng_input' || phase === 'ng_wait') && (
                        <div className="flex flex-col h-full z-10 p-4 bg-slate-950">
                            <div className="flex-none pt-4 pb-2 text-center">
                                <div className="text-xs text-slate-500 tracking-[0.5em] mb-1">MISSION START</div>
                                <div className="text-3xl md:text-4xl font-black text-white py-4 border-y border-cyan-900 bg-cyan-950/20">{selectedTopic?.text}</div>
                            </div>
                            {phase === 'ng_wait' ? (
                                <div className="flex-1 flex flex-col items-center justify-center space-y-4"><div className="w-16 h-16 border-4 border-rose-500 border-t-transparent rounded-full animate-spin"></div><div className="text-rose-500 font-bold animate-pulse">DEPLOYING TRAPS...</div></div>
                            ) : (
                                <div className="flex-1 overflow-y-auto py-6 flex flex-col items-center">
                                    <div className="w-full max-w-md space-y-6 animate-enter">
                                        <div className="flex justify-between items-end"><h2 className="text-xl font-black text-rose-500">TRAP PHASE</h2><div className="text-xl font-mono text-rose-400">{displayTimer}s</div></div>
                                        <div className="space-y-4 p-4 border border-rose-900/50 rounded bg-rose-950/10">
                                            <CyberInput value={ngWords.high} onChange={e => setNgWords({...ngWords, high: toHiragana(e.target.value)})} placeholder="Âç≥Ê≠ª (ÂøÖÈ†à)" label="3PT (FATAL)" color="rose"/>
                                            <CyberInput value={ngWords.mid} onChange={e => setNgWords({...ngWords, mid: toHiragana(e.target.value)})} placeholder="‰∏≠„ÉÄ„É°„Éº„Ç∏" label="2PT (CRITICAL)" color="rose"/>
                                            <CyberInput value={ngWords.low} onChange={e => setNgWords({...ngWords, low: toHiragana(e.target.value)})} placeholder="Â∞è„ÉÄ„É°„Éº„Ç∏" label="1PT (MINOR)" color="rose"/>
                                        </div>
                                        <Button onClick={submitNg} variant="danger" className="w-full py-4 text-lg">BATTLE START</Button>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* GAMEPLAY */}
                    {(phase === 'playing' || phase === 'result') && (
                        <div className="flex flex-col h-full z-10 bg-slate-900/50 relative">
                            {/* HEADER */}
                            <div className="absolute top-0 left-0 right-0 z-30 p-4 bg-slate-900 border-b border-slate-700 shadow-xl flex justify-between items-end">
                                <div className="w-1/3"><div className="text-[10px] text-rose-500 font-bold mb-1 truncate">{oppName}</div><div className="flex gap-1 h-2">{[...Array(MAX_HP)].map((_,i) => <div key={i} className={`flex-1 rounded-sm ${i<oppHp?'bg-rose-500 shadow-[0_0_5px_#f43f5e]':'bg-slate-800'}`}></div>)}</div></div>
                                <div className="text-center"><div className={`text-4xl font-black ${displayTimer<=5?'text-rose-500 animate-pulse':'text-white'}`} style={{fontFamily: 'Black Ops One'}}>{displayTimer}</div></div>
                                <div className="w-1/3 text-right"><div className="text-[10px] text-cyan-400 font-bold mb-1 truncate">{userName || 'YOU'}</div><div className="flex gap-1 h-2 justify-end">{[...Array(MAX_HP)].map((_,i) => <div key={i} className={`flex-1 rounded-sm ${i<myHp?'bg-cyan-400 shadow-[0_0_5px_#06b6d4]':'bg-slate-800'}`}></div>)}</div></div>
                            </div>
                            
                            <div className="h-24 flex-none"></div>

                            {/* BANNER */}
                            <div className="flex-none z-20 space-y-1">
                                <div className="bg-slate-900/80 border-y border-slate-800 py-1 text-center text-xs text-slate-300">MISSION: <span className="text-white font-bold">{selectedTopic?.text}</span></div>
                                <div className="flex justify-center gap-2 px-2">
                                    {[ngWords.high, ngWords.mid, ngWords.low].map((w, i) => w && <div key={i} className="bg-rose-950/60 border border-rose-800 text-rose-300 px-2 py-0.5 text-[10px] rounded backdrop-blur border-b-2">{w} <span className="text-rose-500 font-bold">{3-i}pt</span></div>)}
                                </div>
                            </div>

                            {/* CHAT */}
                            <div className="flex-1 overflow-y-auto p-4 space-y-4 pb-20" ref={scrollRef}>
                                <div className="flex justify-center my-4"><div className="bg-cyan-950/50 border border-cyan-800 text-cyan-300 px-4 py-2 rounded-full text-xs font-bold">START: „Äå{history.length === 0 ? lastChar : ''}„Äç</div></div>
                                {history.map((h, i) => {
                                    if(h.type==='alert') return <div key={i} className="text-center text-[10px] text-rose-400 font-bold bg-rose-950/50 py-1 rounded border border-rose-900 animate-pulse">{h.word}</div>;
                                    const isMine = h.owner === (isHost?'host':'guest');
                                    return (
                                        <div key={i} className={`flex ${isMine?'justify-end':'justify-start'}`}>
                                            <div className={`max-w-[80%] px-4 py-2 rounded font-bold ${isMine?'bg-cyan-900/80 text-cyan-100 border-l-4 border-cyan-400':'bg-slate-800 text-slate-300 border-r-4 border-slate-600'} ${h.damage>0?'!border-rose-500 !text-rose-400 shake-anim':''}`}>
                                                {h.word}
                                                {h.damage>0 && <div className="text-[10px] mt-1 text-rose-500">üí• HIT -{h.damage}</div>}
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>

                            {/* INPUT */}
                            <div className="flex-none p-3 pb-6 bg-black border-t border-slate-800 z-30">
                                <div className="flex justify-between items-center mb-2"><div className="text-xs text-slate-500">LAST: <span className="text-white text-xl font-bold">{lastChar}</span></div><div className={`text-xs font-bold ${isMyTurn?'text-cyan-400 animate-pulse':'text-slate-600'}`}>{isMyTurn?'YOUR TURN':'WAITING'}</div></div>
                                <div className="flex gap-2">
                                    <input value={input} onChange={e=>setInput(e.target.value)} onKeyDown={e=>e.key==='Enter'&&isMyTurn&&phase==='playing'&&submitWord()} disabled={!isMyTurn || phase !== 'playing'} className="flex-1 bg-slate-900 border border-slate-700 text-white px-4 py-3 rounded outline-none focus:border-cyan-500 transition-colors" placeholder="ÂÖ•Âäõ..."/>
                                    <Button onClick={submitWord} disabled={!isMyTurn||!input||phase!=='playing'} icon="send" className="!px-4" />
                                </div>
                            </div>
                        </div>
                    )}

                    {/* RESULT */}
                    {phase === 'result' && (
                        <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black/95 backdrop-blur animate-enter">
                            <h1 className={`text-6xl font-black italic mb-4 glitch-text ${myHp > 0 ? 'text-cyan-400' : 'text-rose-500'}`}>{myHp > 0 ? 'VICTORY' : 'DEFEAT'}</h1>
                            <div className="text-center mb-8"><div className="text-xs text-slate-500 tracking-widest mb-1">FINAL STATUS</div><div className="text-2xl font-mono text-white">{userName} HP: {myHp} / {oppName} HP: {oppHp}</div></div>
                            <Button onClick={handleRematch} className="px-12 py-4 text-xl">REMATCH</Button>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
